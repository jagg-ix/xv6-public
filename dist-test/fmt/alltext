0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #ifndef __ASSEMBLER__
0211 
0212 static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
0213 static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
0214 
0215 #endif
0216 
0217 #define V2P(a) (((uint) (a)) - KERNBASE)
0218 #define P2V(a) (((void *) (a)) + KERNBASE)
0219 
0220 #define V2P_WO(x) ((x) - KERNBASE)    
0221 #define P2V_WO(x) ((x) + KERNBASE)    
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct stat;
0259 struct superblock;
0260 
0261 
0262 void            binit(void);
0263 struct buf*     bread(uint, uint);
0264 void            brelse(struct buf*);
0265 void            bwrite(struct buf*);
0266 
0267 
0268 void            consoleinit(void);
0269 void            cprintf(char*, ...);
0270 void            consoleintr(int(*)(void));
0271 void            panic(char*) __attribute__((noreturn));
0272 
0273 
0274 int             exec(char*, char**);
0275 
0276 
0277 struct file*    filealloc(void);
0278 void            fileclose(struct file*);
0279 struct file*    filedup(struct file*);
0280 void            fileinit(void);
0281 int             fileread(struct file*, char*, int n);
0282 int             filestat(struct file*, struct stat*);
0283 int             filewrite(struct file*, char*, int n);
0284 
0285 
0286 void            readsb(int dev, struct superblock *sb);
0287 int             dirlink(struct inode*, char*, uint);
0288 struct inode*   dirlookup(struct inode*, char*, uint*);
0289 struct inode*   ialloc(uint, short);
0290 struct inode*   idup(struct inode*);
0291 void            iinit(int dev);
0292 void            ilock(struct inode*);
0293 void            iput(struct inode*);
0294 void            iunlock(struct inode*);
0295 void            iunlockput(struct inode*);
0296 void            iupdate(struct inode*);
0297 int             namecmp(const char*, const char*);
0298 struct inode*   namei(char*);
0299 struct inode*   nameiparent(char*, char*);
0300 int             readi(struct inode*, char*, uint, uint);
0301 void            stati(struct inode*, struct stat*);
0302 int             writei(struct inode*, char*, uint, uint);
0303 
0304 
0305 void            ideinit(void);
0306 void            ideintr(void);
0307 void            iderw(struct buf*);
0308 
0309 
0310 void            ioapicenable(int irq, int cpu);
0311 extern uchar    ioapicid;
0312 void            ioapicinit(void);
0313 
0314 
0315 char*           kalloc(void);
0316 void            kfree(char*);
0317 void            kinit1(void*, void*);
0318 void            kinit2(void*, void*);
0319 
0320 
0321 void            kbdintr(void);
0322 
0323 
0324 void            cmostime(struct rtcdate *r);
0325 int             cpunum(void);
0326 extern volatile uint*    lapic;
0327 void            lapiceoi(void);
0328 void            lapicinit(void);
0329 void            lapicstartap(uchar, uint);
0330 void            microdelay(int);
0331 
0332 
0333 void            initlog(int dev);
0334 void            log_write(struct buf*);
0335 void            begin_op();
0336 void            end_op();
0337 
0338 
0339 extern int      ismp;
0340 int             mpbcpu(void);
0341 void            mpinit(void);
0342 void            mpstartthem(void);
0343 
0344 
0345 void            picenable(int);
0346 void            picinit(void);
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 struct proc*    copyproc(struct proc*);
0358 void            exit(void);
0359 int             fork(void);
0360 int             growproc(int);
0361 int             kill(int);
0362 void            pinit(void);
0363 void            procdump(void);
0364 void            scheduler(void) __attribute__((noreturn));
0365 void            sched(void);
0366 void            sleep(void*, struct spinlock*);
0367 void            userinit(void);
0368 int             wait(void);
0369 void            wakeup(void*);
0370 void            yield(void);
0371 
0372 
0373 void            swtch(struct context**, struct context*);
0374 
0375 
0376 void            acquire(struct spinlock*);
0377 void            getcallerpcs(void*, uint*);
0378 int             holding(struct spinlock*);
0379 void            initlock(struct spinlock*, char*);
0380 void            release(struct spinlock*);
0381 void            pushcli(void);
0382 void            popcli(void);
0383 
0384 
0385 int             memcmp(const void*, const void*, uint);
0386 void*           memmove(void*, const void*, uint);
0387 void*           memset(void*, int, uint);
0388 char*           safestrcpy(char*, const char*, int);
0389 int             strlen(const char*);
0390 int             strncmp(const char*, const char*, uint);
0391 char*           strncpy(char*, const char*, int);
0392 
0393 
0394 int             argint(int, int*);
0395 int             argptr(int, char**, int);
0396 int             argstr(int, char**);
0397 int             fetchint(uint, int*);
0398 int             fetchstr(uint, char**);
0399 void            syscall(void);
0400 
0401 void            timerinit(void);
0402 
0403 
0404 void            idtinit(void);
0405 extern uint     ticks;
0406 void            tvinit(void);
0407 extern struct spinlock tickslock;
0408 
0409 
0410 void            uartinit(void);
0411 void            uartintr(void);
0412 void            uartputc(int);
0413 
0414 
0415 void            seginit(void);
0416 void            kvmalloc(void);
0417 void            vmenable(void);
0418 pde_t*          setupkvm(void);
0419 char*           uva2ka(pde_t*, char*);
0420 int             allocuvm(pde_t*, uint, uint);
0421 int             deallocuvm(pde_t*, uint, uint);
0422 void            freevm(pde_t*);
0423 void            inituvm(pde_t*, char*, uint);
0424 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0425 pde_t*          copyuvm(pde_t*, uint);
0426 void            switchuvm(struct proc*);
0427 void            switchkvm(void);
0428 int             copyout(pde_t*, uint, void*, uint);
0429 void            clearpteu(pde_t *pgdir, char *uva);
0430 
0431 
0432 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0433 
0434 
0435 
0436 
0437 
0438 
0439 
0440 
0441 
0442 
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_E     0x4       
0667 #define STA_C     0x4       
0668 #define STA_W     0x2       
0669 #define STA_R     0x2       
0670 #define STA_A     0x1       
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_CF           0x00000001      
0705 #define FL_PF           0x00000004      
0706 #define FL_AF           0x00000010      
0707 #define FL_ZF           0x00000040      
0708 #define FL_SF           0x00000080      
0709 #define FL_TF           0x00000100      
0710 #define FL_IF           0x00000200      
0711 #define FL_DF           0x00000400      
0712 #define FL_OF           0x00000800      
0713 #define FL_IOPL_MASK    0x00003000      
0714 #define FL_IOPL_0       0x00000000      
0715 #define FL_IOPL_1       0x00001000      
0716 #define FL_IOPL_2       0x00002000      
0717 #define FL_IOPL_3       0x00003000      
0718 #define FL_NT           0x00004000      
0719 #define FL_RF           0x00010000      
0720 #define FL_VM           0x00020000      
0721 #define FL_AC           0x00040000      
0722 #define FL_VIF          0x00080000      
0723 #define FL_VIP          0x00100000      
0724 #define FL_ID           0x00200000      
0725 
0726 
0727 #define CR0_PE          0x00000001      
0728 #define CR0_MP          0x00000002      
0729 #define CR0_EM          0x00000004      
0730 #define CR0_TS          0x00000008      
0731 #define CR0_ET          0x00000010      
0732 #define CR0_NE          0x00000020      
0733 #define CR0_WP          0x00010000      
0734 #define CR0_AM          0x00040000      
0735 #define CR0_NW          0x20000000      
0736 #define CR0_CD          0x40000000      
0737 #define CR0_PG          0x80000000      
0738 
0739 #define CR4_PSE         0x00000010      
0740 
0741 #define SEG_KCODE 1  
0742 #define SEG_KDATA 2  
0743 #define SEG_KCPU  3  
0744 #define SEG_UCODE 4  
0745 #define SEG_UDATA 5  
0746 #define SEG_TSS   6  
0747 
0748 
0749 
0750 #ifndef __ASSEMBLER__
0751 
0752 struct segdesc {
0753   uint lim_15_0 : 16;  
0754   uint base_15_0 : 16; 
0755   uint base_23_16 : 8; 
0756   uint type : 4;       
0757   uint s : 1;          
0758   uint dpl : 2;        
0759   uint p : 1;          
0760   uint lim_19_16 : 4;  
0761   uint avl : 1;        
0762   uint rsv1 : 1;       
0763   uint db : 1;         
0764   uint g : 1;          
0765   uint base_31_24 : 8; 
0766 };
0767 
0768 
0769 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0770 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0771   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0772   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0773 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0774 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0775   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0776   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0777 #endif
0778 
0779 #define DPL_USER    0x3     
0780 
0781 
0782 #define STA_X       0x8     
0783 #define STA_E       0x4     
0784 #define STA_C       0x4     
0785 #define STA_W       0x2     
0786 #define STA_R       0x2     
0787 #define STA_A       0x1     
0788 
0789 
0790 #define STS_T16A    0x1     
0791 #define STS_LDT     0x2     
0792 #define STS_T16B    0x3     
0793 #define STS_CG16    0x4     
0794 #define STS_TG      0x5     
0795 #define STS_IG16    0x6     
0796 #define STS_TG16    0x7     
0797 #define STS_T32A    0x9     
0798 #define STS_T32B    0xB     
0799 #define STS_CG32    0xC     
0800 #define STS_IG32    0xE     
0801 #define STS_TG32    0xF     
0802 
0803 
0804 
0805 
0806 
0807 
0808 
0809 
0810 
0811 
0812 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0813 
0814 
0815 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0816 
0817 
0818 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0819 
0820 
0821 #define NPDENTRIES      1024    
0822 #define NPTENTRIES      1024    
0823 #define PGSIZE          4096    
0824 
0825 #define PGSHIFT         12      
0826 #define PTXSHIFT        12      
0827 #define PDXSHIFT        22      
0828 
0829 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0830 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0831 
0832 
0833 #define PTE_P           0x001   
0834 #define PTE_W           0x002   
0835 #define PTE_U           0x004   
0836 #define PTE_PWT         0x008   
0837 #define PTE_PCD         0x010   
0838 #define PTE_A           0x020   
0839 #define PTE_D           0x040   
0840 #define PTE_PS          0x080   
0841 #define PTE_MBZ         0x180   
0842 
0843 
0844 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0845 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0846 
0847 #ifndef __ASSEMBLER__
0848 typedef uint pte_t;
0849 
0850 
0851 struct taskstate {
0852   uint link;         
0853   uint esp0;         
0854   ushort ss0;        
0855   ushort padding1;
0856   uint *esp1;
0857   ushort ss1;
0858   ushort padding2;
0859   uint *esp2;
0860   ushort ss2;
0861   ushort padding3;
0862   void *cr3;         
0863   uint *eip;         
0864   uint eflags;
0865   uint eax;          
0866   uint ecx;
0867   uint edx;
0868   uint ebx;
0869   uint *esp;
0870   uint *ebp;
0871   uint esi;
0872   uint edi;
0873   ushort es;         
0874   ushort padding4;
0875   ushort cs;
0876   ushort padding5;
0877   ushort ss;
0878   ushort padding6;
0879   ushort ds;
0880   ushort padding7;
0881   ushort fs;
0882   ushort padding8;
0883   ushort gs;
0884   ushort padding9;
0885   ushort ldt;
0886   ushort padding10;
0887   ushort t;          
0888   ushort iomb;       
0889 };
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 struct gatedesc {
0902   uint off_15_0 : 16;   
0903   uint cs : 16;         
0904   uint args : 5;        
0905   uint rsv1 : 3;        
0906   uint type : 4;        
0907   uint s : 1;           
0908   uint dpl : 2;         
0909   uint p : 1;           
0910   uint off_31_16 : 16;  
0911 };
0912 
0913 
0914 
0915 
0916 
0917 
0918 
0919 
0920 
0921 #define SETGATE(gate, istrap, sel, off, d)                \
0922 {                                                         \
0923   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0924   (gate).cs = (sel);                                      \
0925   (gate).args = 0;                                        \
0926   (gate).rsv1 = 0;                                        \
0927   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0928   (gate).s = 0;                                           \
0929   (gate).dpl = (d);                                       \
0930   (gate).p = 1;                                           \
0931   (gate).off_31_16 = (uint)(off) >> 16;                  \
0932 }
0933 
0934 #endif
0935 
0936 
0937 
0938 
0939 
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 .p2align 2
1023 .text
1024 .globl multiboot_header
1025 multiboot_header:
1026   
1027   
1028   .long magic
1029   .long flags
1030   .long (-magic-flags)
1031 
1032 
1033 
1034 
1035 .globl _start
1036 _start = V2P_WO(entry)
1037 
1038 
1039 .globl entry
1040 entry:
1041   
1042   movl    %cr4, %eax
1043   orl     $(CR4_PSE), %eax
1044   movl    %eax, %cr4
1045   
1046   movl    $(V2P_WO(entrypgdir)), %eax
1047   movl    %eax, %cr3
1048   
1049   movl    %cr0, %eax
1050   orl     $(CR0_PG|CR0_WP), %eax
1051   movl    %eax, %cr0
1052 
1053   
1054   movl $(stack + KSTACKSIZE), %esp
1055 
1056   
1057   
1058   
1059   
1060   mov $main, %eax
1061   jmp *%eax
1062 
1063 .comm stack, KSTACKSIZE
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 
1122 
1123 .code16
1124 .globl start
1125 start:
1126   cli
1127 
1128   xorw    %ax,%ax
1129   movw    %ax,%ds
1130   movw    %ax,%es
1131   movw    %ax,%ss
1132 
1133   lgdt    gdtdesc
1134   movl    %cr0, %eax
1135   orl     $CR0_PE, %eax
1136   movl    %eax, %cr0
1137 
1138   ljmpl    $(SEG_KCODE<<3), $(start32)
1139 
1140 .code32
1141 start32:
1142   movw    $(SEG_KDATA<<3), %ax
1143   movw    %ax, %ds
1144   movw    %ax, %es
1145   movw    %ax, %ss
1146   movw    $0, %ax
1147   movw    %ax, %fs
1148   movw    %ax, %gs
1149 
1150   
1151   movl    %cr4, %eax
1152   orl     $(CR4_PSE), %eax
1153   movl    %eax, %cr4
1154   
1155   movl    (start-12), %eax
1156   movl    %eax, %cr3
1157   
1158   movl    %cr0, %eax
1159   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1160   movl    %eax, %cr0
1161 
1162   
1163   movl    (start-4), %esp
1164   
1165   call	 *(start-8)
1166 
1167   movw    $0x8a00, %ax
1168   movw    %ax, %dx
1169   outw    %ax, %dx
1170   movw    $0x8ae0, %ax
1171   outw    %ax, %dx
1172 spin:
1173   jmp     spin
1174 
1175 .p2align 2
1176 gdt:
1177   SEG_NULLASM
1178   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1179   SEG_ASM(STA_W, 0, 0xffffffff)
1180 
1181 
1182 gdtdesc:
1183   .word   (gdtdesc - gdt - 1)
1184   .long   gdt
1185 
1186 
1187 
1188 
1189 
1190 
1191 
1192 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();
1223   seginit();       
1224   cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
1225   picinit();       
1226   ioapicinit();    
1227   consoleinit();   
1228   uartinit();      
1229   pinit();         
1230   tvinit();        
1231   binit();         
1232   fileinit();      
1233   ideinit();       
1234   if(!ismp)
1235     timerinit();   
1236   startothers();   
1237   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1238   userinit();      
1239   
1240   mpmain();
1241 }
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 static void
1252 mpenter(void)
1253 {
1254   switchkvm();
1255   seginit();
1256   lapicinit();
1257   mpmain();
1258 }
1259 
1260 
1261 static void
1262 mpmain(void)
1263 {
1264   cprintf("cpu%d: starting\n", cpu->id);
1265   idtinit();       
1266   xchg(&cpu->started, 1); 
1267   scheduler();     
1268 }
1269 
1270 pde_t entrypgdir[];  
1271 
1272 
1273 static void
1274 startothers(void)
1275 {
1276   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1277   uchar *code;
1278   struct cpu *c;
1279   char *stack;
1280 
1281   
1282   
1283   
1284   code = p2v(0x7000);
1285   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1286 
1287   for(c = cpus; c < cpus+ncpu; c++){
1288     if(c == cpus+cpunum())  
1289       continue;
1290 
1291     
1292     
1293     
1294     stack = kalloc();
1295     *(void**)(code-4) = stack + KSTACKSIZE;
1296     *(void**)(code-8) = mpenter;
1297     *(int**)(code-12) = (void *) v2p(entrypgdir);
1298 
1299     lapicstartap(c->id, v2p(code));
1300     
1301     while(c->started == 0)
1302       ;
1303   }
1304 }
1305 
1306 
1307 
1308 
1309 
1310 __attribute__((__aligned__(PGSIZE)))
1311 pde_t entrypgdir[NPDENTRIES] = {
1312   
1313   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1314   
1315   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1316 };
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 struct spinlock {
1352   uint locked;       
1353 
1354   
1355   char *name;        
1356   struct cpu *cpu;   
1357   uint pcs[10];      
1358                      
1359 };
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 #include "types.h"
1403 #include "defs.h"
1404 #include "param.h"
1405 #include "x86.h"
1406 #include "memlayout.h"
1407 #include "mmu.h"
1408 #include "proc.h"
1409 #include "spinlock.h"
1410 
1411 void
1412 initlock(struct spinlock *lk, char *name)
1413 {
1414   lk->name = name;
1415   lk->locked = 0;
1416   lk->cpu = 0;
1417 }
1418 
1419 
1420 
1421 
1422 
1423 void
1424 acquire(struct spinlock *lk)
1425 {
1426   pushcli(); 
1427   if(holding(lk))
1428     panic("acquire");
1429 
1430   
1431   
1432   
1433   while(xchg(&lk->locked, 1) != 0)
1434     ;
1435 
1436   
1437   lk->cpu = cpu;
1438   getcallerpcs(&lk, lk->pcs);
1439 }
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 void
1452 release(struct spinlock *lk)
1453 {
1454   if(!holding(lk))
1455     panic("release");
1456 
1457   lk->pcs[0] = 0;
1458   lk->cpu = 0;
1459 
1460   
1461   
1462   
1463   
1464   
1465   
1466   
1467   
1468   
1469   xchg(&lk->locked, 0);
1470 
1471   popcli();
1472 }
1473 
1474 
1475 void
1476 getcallerpcs(void *v, uint pcs[])
1477 {
1478   uint *ebp;
1479   int i;
1480 
1481   ebp = (uint*)v - 2;
1482   for(i = 0; i < 10; i++){
1483     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1484       break;
1485     pcs[i] = ebp[1];     
1486     ebp = (uint*)ebp[0]; 
1487   }
1488   for(; i < 10; i++)
1489     pcs[i] = 0;
1490 }
1491 
1492 
1493 int
1494 holding(struct spinlock *lock)
1495 {
1496   return lock->locked && lock->cpu == cpu;
1497 }
1498 
1499 
1500 
1501 
1502 
1503 
1504 void
1505 pushcli(void)
1506 {
1507   int eflags;
1508 
1509   eflags = readeflags();
1510   cli();
1511   if(cpu->ncli++ == 0)
1512     cpu->intena = eflags & FL_IF;
1513 }
1514 
1515 void
1516 popcli(void)
1517 {
1518   if(readeflags()&FL_IF)
1519     panic("popcli - interruptible");
1520   if(--cpu->ncli < 0)
1521     panic("popcli");
1522   if(cpu->ncli == 0 && cpu->intena)
1523     sti();
1524 }
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 #include "param.h"
1551 #include "types.h"
1552 #include "defs.h"
1553 #include "x86.h"
1554 #include "memlayout.h"
1555 #include "mmu.h"
1556 #include "proc.h"
1557 #include "elf.h"
1558 
1559 extern char data[];  
1560 pde_t *kpgdir;  
1561 struct segdesc gdt[NSEGS];
1562 
1563 
1564 
1565 void
1566 seginit(void)
1567 {
1568   struct cpu *c;
1569 
1570   
1571   
1572   
1573   
1574   c = &cpus[cpunum()];
1575   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1576   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1577   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1578   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1579 
1580   
1581   c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
1582 
1583   lgdt(c->gdt, sizeof(c->gdt));
1584   loadgs(SEG_KCPU << 3);
1585 
1586   
1587   cpu = c;
1588   proc = 0;
1589 }
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 
1602 
1603 static pte_t *
1604 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1605 {
1606   pde_t *pde;
1607   pte_t *pgtab;
1608 
1609   pde = &pgdir[PDX(va)];
1610   if(*pde & PTE_P){
1611     pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
1612   } else {
1613     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1614       return 0;
1615     
1616     memset(pgtab, 0, PGSIZE);
1617     
1618     
1619     
1620     *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
1621   }
1622   return &pgtab[PTX(va)];
1623 }
1624 
1625 
1626 
1627 
1628 static int
1629 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1630 {
1631   char *a, *last;
1632   pte_t *pte;
1633 
1634   a = (char*)PGROUNDDOWN((uint)va);
1635   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1636   for(;;){
1637     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1638       return -1;
1639     if(*pte & PTE_P)
1640       panic("remap");
1641     *pte = pa | perm | PTE_P;
1642     if(a == last)
1643       break;
1644     a += PGSIZE;
1645     pa += PGSIZE;
1646   }
1647   return 0;
1648 }
1649 
1650 
1651 
1652 
1653 
1654 
1655 
1656 
1657 
1658 
1659 
1660 
1661 
1662 
1663 
1664 
1665 
1666 
1667 
1668 
1669 
1670 
1671 
1672 
1673 static struct kmap {
1674   void *virt;
1675   uint phys_start;
1676   uint phys_end;
1677   int perm;
1678 } kmap[] = {
1679  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1680  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1681  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1682  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1683 };
1684 
1685 
1686 pde_t*
1687 setupkvm(void)
1688 {
1689   pde_t *pgdir;
1690   struct kmap *k;
1691 
1692   if((pgdir = (pde_t*)kalloc()) == 0)
1693     return 0;
1694   memset(pgdir, 0, PGSIZE);
1695   if (p2v(PHYSTOP) > (void*)DEVSPACE)
1696     panic("PHYSTOP too high");
1697   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1698     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1699                 (uint)k->phys_start, k->perm) < 0)
1700       return 0;
1701   return pgdir;
1702 }
1703 
1704 
1705 
1706 void
1707 kvmalloc(void)
1708 {
1709   kpgdir = setupkvm();
1710   switchkvm();
1711 }
1712 
1713 
1714 
1715 void
1716 switchkvm(void)
1717 {
1718   lcr3(v2p(kpgdir));   
1719 }
1720 
1721 
1722 void
1723 switchuvm(struct proc *p)
1724 {
1725   pushcli();
1726   cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
1727   cpu->gdt[SEG_TSS].s = 0;
1728   cpu->ts.ss0 = SEG_KDATA << 3;
1729   cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
1730   ltr(SEG_TSS << 3);
1731   if(p->pgdir == 0)
1732     panic("switchuvm: no pgdir");
1733   lcr3(v2p(p->pgdir));  
1734   popcli();
1735 }
1736 
1737 
1738 
1739 
1740 
1741 
1742 
1743 
1744 
1745 
1746 
1747 
1748 
1749 
1750 
1751 
1752 void
1753 inituvm(pde_t *pgdir, char *init, uint sz)
1754 {
1755   char *mem;
1756 
1757   if(sz >= PGSIZE)
1758     panic("inituvm: more than a page");
1759   mem = kalloc();
1760   memset(mem, 0, PGSIZE);
1761   mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
1762   memmove(mem, init, sz);
1763 }
1764 
1765 
1766 
1767 int
1768 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1769 {
1770   uint i, pa, n;
1771   pte_t *pte;
1772 
1773   if((uint) addr % PGSIZE != 0)
1774     panic("loaduvm: addr must be page aligned");
1775   for(i = 0; i < sz; i += PGSIZE){
1776     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1777       panic("loaduvm: address should exist");
1778     pa = PTE_ADDR(*pte);
1779     if(sz - i < PGSIZE)
1780       n = sz - i;
1781     else
1782       n = PGSIZE;
1783     if(readi(ip, p2v(pa), offset+i, n) != n)
1784       return -1;
1785   }
1786   return 0;
1787 }
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 int
1803 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1804 {
1805   char *mem;
1806   uint a;
1807 
1808   if(newsz >= KERNBASE)
1809     return 0;
1810   if(newsz < oldsz)
1811     return oldsz;
1812 
1813   a = PGROUNDUP(oldsz);
1814   for(; a < newsz; a += PGSIZE){
1815     mem = kalloc();
1816     if(mem == 0){
1817       cprintf("allocuvm out of memory\n");
1818       deallocuvm(pgdir, newsz, oldsz);
1819       return 0;
1820     }
1821     memset(mem, 0, PGSIZE);
1822     mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
1823   }
1824   return newsz;
1825 }
1826 
1827 
1828 
1829 
1830 
1831 int
1832 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1833 {
1834   pte_t *pte;
1835   uint a, pa;
1836 
1837   if(newsz >= oldsz)
1838     return oldsz;
1839 
1840   a = PGROUNDUP(newsz);
1841   for(; a  < oldsz; a += PGSIZE){
1842     pte = walkpgdir(pgdir, (char*)a, 0);
1843     if(!pte)
1844       a += (NPTENTRIES - 1) * PGSIZE;
1845     else if((*pte & PTE_P) != 0){
1846       pa = PTE_ADDR(*pte);
1847       if(pa == 0)
1848         panic("kfree");
1849       char *v = p2v(pa);
1850       kfree(v);
1851       *pte = 0;
1852     }
1853   }
1854   return newsz;
1855 }
1856 
1857 
1858 
1859 void
1860 freevm(pde_t *pgdir)
1861 {
1862   uint i;
1863 
1864   if(pgdir == 0)
1865     panic("freevm: no pgdir");
1866   deallocuvm(pgdir, KERNBASE, 0);
1867   for(i = 0; i < NPDENTRIES; i++){
1868     if(pgdir[i] & PTE_P){
1869       char * v = p2v(PTE_ADDR(pgdir[i]));
1870       kfree(v);
1871     }
1872   }
1873   kfree((char*)pgdir);
1874 }
1875 
1876 
1877 
1878 void
1879 clearpteu(pde_t *pgdir, char *uva)
1880 {
1881   pte_t *pte;
1882 
1883   pte = walkpgdir(pgdir, uva, 0);
1884   if(pte == 0)
1885     panic("clearpteu");
1886   *pte &= ~PTE_U;
1887 }
1888 
1889 
1890 
1891 
1892 
1893 
1894 
1895 
1896 
1897 
1898 
1899 
1900 
1901 
1902 pde_t*
1903 copyuvm(pde_t *pgdir, uint sz)
1904 {
1905   pde_t *d;
1906   pte_t *pte;
1907   uint pa, i, flags;
1908   char *mem;
1909 
1910   if((d = setupkvm()) == 0)
1911     return 0;
1912   for(i = 0; i < sz; i += PGSIZE){
1913     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
1914       panic("copyuvm: pte should exist");
1915     if(!(*pte & PTE_P))
1916       panic("copyuvm: page not present");
1917     pa = PTE_ADDR(*pte);
1918     flags = PTE_FLAGS(*pte);
1919     if((mem = kalloc()) == 0)
1920       goto bad;
1921     memmove(mem, (char*)p2v(pa), PGSIZE);
1922     if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
1923       goto bad;
1924   }
1925   return d;
1926 
1927 bad:
1928   freevm(d);
1929   return 0;
1930 }
1931 
1932 
1933 char*
1934 uva2ka(pde_t *pgdir, char *uva)
1935 {
1936   pte_t *pte;
1937 
1938   pte = walkpgdir(pgdir, uva, 0);
1939   if((*pte & PTE_P) == 0)
1940     return 0;
1941   if((*pte & PTE_U) == 0)
1942     return 0;
1943   return (char*)p2v(PTE_ADDR(*pte));
1944 }
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952 
1953 int
1954 copyout(pde_t *pgdir, uint va, void *p, uint len)
1955 {
1956   char *buf, *pa0;
1957   uint n, va0;
1958 
1959   buf = (char*)p;
1960   while(len > 0){
1961     va0 = (uint)PGROUNDDOWN(va);
1962     pa0 = uva2ka(pgdir, (char*)va0);
1963     if(pa0 == 0)
1964       return -1;
1965     n = PGSIZE - (va - va0);
1966     if(n > len)
1967       n = len;
1968     memmove(pa0 + (va - va0), buf, n);
1969     len -= n;
1970     buf += n;
1971     va = va0 + PGSIZE;
1972   }
1973   return 0;
1974 }
1975 
1976 
1977 
1978 
1979 
1980 
1981 
1982 
1983 
1984 
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 #define NSEGS     7
2002 
2003 
2004 struct cpu {
2005   uchar id;                    
2006   struct context *scheduler;   
2007   struct taskstate ts;         
2008   struct segdesc gdt[NSEGS];   
2009   volatile uint started;       
2010   int ncli;                    
2011   int intena;                  
2012 
2013   
2014   struct cpu *cpu;
2015   struct proc *proc;           
2016 };
2017 
2018 extern struct cpu cpus[NCPU];
2019 extern int ncpu;
2020 
2021 
2022 
2023 
2024 
2025 
2026 
2027 
2028 
2029 extern struct cpu *cpu asm("%gs:0");       
2030 extern struct proc *proc asm("%gs:4");     
2031 
2032 
2033 
2034 
2035 
2036 
2037 
2038 
2039 
2040 
2041 
2042 struct context {
2043   uint edi;
2044   uint esi;
2045   uint ebx;
2046   uint ebp;
2047   uint eip;
2048 };
2049 
2050 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2051 
2052 
2053 struct proc {
2054   uint sz;                     
2055   pde_t* pgdir;                
2056   char *kstack;                
2057   enum procstate state;        
2058   int pid;                     
2059   struct proc *parent;         
2060   struct trapframe *tf;        
2061   struct context *context;     
2062   void *chan;                  
2063   int killed;                  
2064   struct file *ofile[NOFILE];  
2065   struct inode *cwd;           
2066   char name[16];               
2067 };
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 #include "types.h"
2101 #include "defs.h"
2102 #include "param.h"
2103 #include "memlayout.h"
2104 #include "mmu.h"
2105 #include "x86.h"
2106 #include "proc.h"
2107 #include "spinlock.h"
2108 
2109 struct {
2110   struct spinlock lock;
2111   struct proc proc[NPROC];
2112 } ptable;
2113 
2114 static struct proc *initproc;
2115 
2116 int nextpid = 1;
2117 extern void forkret(void);
2118 extern void trapret(void);
2119 
2120 static void wakeup1(void *chan);
2121 
2122 void
2123 pinit(void)
2124 {
2125   initlock(&ptable.lock, "ptable");
2126 }
2127 
2128 
2129 
2130 
2131 
2132 static struct proc*
2133 allocproc(void)
2134 {
2135   struct proc *p;
2136   char *sp;
2137 
2138   acquire(&ptable.lock);
2139   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2140     if(p->state == UNUSED)
2141       goto found;
2142   release(&ptable.lock);
2143   return 0;
2144 
2145 found:
2146   p->state = EMBRYO;
2147   p->pid = nextpid++;
2148   release(&ptable.lock);
2149 
2150   
2151   if((p->kstack = kalloc()) == 0){
2152     p->state = UNUSED;
2153     return 0;
2154   }
2155   sp = p->kstack + KSTACKSIZE;
2156 
2157   
2158   sp -= sizeof *p->tf;
2159   p->tf = (struct trapframe*)sp;
2160 
2161   
2162   
2163   sp -= 4;
2164   *(uint*)sp = (uint)trapret;
2165 
2166   sp -= sizeof *p->context;
2167   p->context = (struct context*)sp;
2168   memset(p->context, 0, sizeof *p->context);
2169   p->context->eip = (uint)forkret;
2170 
2171   return p;
2172 }
2173 
2174 
2175 void
2176 userinit(void)
2177 {
2178   struct proc *p;
2179   extern char _binary_initcode_start[], _binary_initcode_size[];
2180 
2181   p = allocproc();
2182   initproc = p;
2183   if((p->pgdir = setupkvm()) == 0)
2184     panic("userinit: out of memory?");
2185   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2186   p->sz = PGSIZE;
2187   memset(p->tf, 0, sizeof(*p->tf));
2188   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2189   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2190   p->tf->es = p->tf->ds;
2191   p->tf->ss = p->tf->ds;
2192   p->tf->eflags = FL_IF;
2193   p->tf->esp = PGSIZE;
2194   p->tf->eip = 0;  
2195 
2196   safestrcpy(p->name, "initcode", sizeof(p->name));
2197   p->cwd = namei("/");
2198 
2199 
2200   p->state = RUNNABLE;
2201 }
2202 
2203 
2204 
2205 int
2206 growproc(int n)
2207 {
2208   uint sz;
2209 
2210   sz = proc->sz;
2211   if(n > 0){
2212     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
2213       return -1;
2214   } else if(n < 0){
2215     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
2216       return -1;
2217   }
2218   proc->sz = sz;
2219   switchuvm(proc);
2220   return 0;
2221 }
2222 
2223 
2224 
2225 
2226 int
2227 fork(void)
2228 {
2229   int i, pid;
2230   struct proc *np;
2231 
2232   
2233   if((np = allocproc()) == 0)
2234     return -1;
2235 
2236   
2237   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
2238     kfree(np->kstack);
2239     np->kstack = 0;
2240     np->state = UNUSED;
2241     return -1;
2242   }
2243   np->sz = proc->sz;
2244   np->parent = proc;
2245   *np->tf = *proc->tf;
2246 
2247   
2248   np->tf->eax = 0;
2249 
2250   for(i = 0; i < NOFILE; i++)
2251     if(proc->ofile[i])
2252       np->ofile[i] = filedup(proc->ofile[i]);
2253   np->cwd = idup(proc->cwd);
2254 
2255   safestrcpy(np->name, proc->name, sizeof(proc->name));
2256 
2257   pid = np->pid;
2258 
2259   
2260   acquire(&ptable.lock);
2261   np->state = RUNNABLE;
2262   release(&ptable.lock);
2263 
2264   return pid;
2265 }
2266 
2267 
2268 
2269 
2270 void
2271 exit(void)
2272 {
2273   struct proc *p;
2274   int fd;
2275 
2276   if(proc == initproc)
2277     panic("init exiting");
2278 
2279   
2280   for(fd = 0; fd < NOFILE; fd++){
2281     if(proc->ofile[fd]){
2282       fileclose(proc->ofile[fd]);
2283       proc->ofile[fd] = 0;
2284     }
2285   }
2286 
2287   begin_op();
2288   iput(proc->cwd);
2289   end_op();
2290   proc->cwd = 0;
2291 
2292   acquire(&ptable.lock);
2293 
2294   
2295   wakeup1(proc->parent);
2296 
2297 
2298 
2299 
2300   
2301   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2302     if(p->parent == proc){
2303       p->parent = initproc;
2304       if(p->state == ZOMBIE)
2305         wakeup1(initproc);
2306     }
2307   }
2308 
2309   
2310   proc->state = ZOMBIE;
2311   sched();
2312   panic("zombie exit");
2313 }
2314 
2315 
2316 
2317 int
2318 wait(void)
2319 {
2320   struct proc *p;
2321   int havekids, pid;
2322 
2323   acquire(&ptable.lock);
2324   for(;;){
2325     
2326     havekids = 0;
2327     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2328       if(p->parent != proc)
2329         continue;
2330       havekids = 1;
2331       if(p->state == ZOMBIE){
2332         
2333         pid = p->pid;
2334         kfree(p->kstack);
2335         p->kstack = 0;
2336         freevm(p->pgdir);
2337         p->state = UNUSED;
2338         p->pid = 0;
2339         p->parent = 0;
2340         p->name[0] = 0;
2341         p->killed = 0;
2342         release(&ptable.lock);
2343         return pid;
2344       }
2345     }
2346 
2347 
2348 
2349 
2350     
2351     if(!havekids || proc->killed){
2352       release(&ptable.lock);
2353       return -1;
2354     }
2355 
2356     
2357     sleep(proc, &ptable.lock);  
2358   }
2359 }
2360 
2361 
2362 
2363 
2364 
2365 
2366 
2367 
2368 void
2369 scheduler(void)
2370 {
2371   struct proc *p;
2372 
2373   for(;;){
2374     
2375     sti();
2376 
2377     
2378     acquire(&ptable.lock);
2379     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2380       if(p->state != RUNNABLE)
2381         continue;
2382 
2383       
2384       
2385       
2386       proc = p;
2387       switchuvm(p);
2388       p->state = RUNNING;
2389       swtch(&cpu->scheduler, proc->context);
2390       switchkvm();
2391 
2392       
2393       
2394       proc = 0;
2395     }
2396     release(&ptable.lock);
2397 
2398   }
2399 }
2400 
2401 
2402 void
2403 sched(void)
2404 {
2405   int intena;
2406 
2407   if(!holding(&ptable.lock))
2408     panic("sched ptable.lock");
2409   if(cpu->ncli != 1)
2410     panic("sched locks");
2411   if(proc->state == RUNNING)
2412     panic("sched running");
2413   if(readeflags()&FL_IF)
2414     panic("sched interruptible");
2415   intena = cpu->intena;
2416   swtch(&proc->context, cpu->scheduler);
2417   cpu->intena = intena;
2418 }
2419 
2420 
2421 void
2422 yield(void)
2423 {
2424   acquire(&ptable.lock);  
2425   proc->state = RUNNABLE;
2426   sched();
2427   release(&ptable.lock);
2428 }
2429 
2430 
2431 
2432 void
2433 forkret(void)
2434 {
2435   static int first = 1;
2436   
2437   release(&ptable.lock);
2438 
2439   if (first) {
2440     
2441     
2442     
2443     first = 0;
2444     iinit(ROOTDEV);
2445     initlog(ROOTDEV);
2446   }
2447 
2448   
2449 }
2450 
2451 
2452 void
2453 sleep(void *chan, struct spinlock *lk)
2454 {
2455   if(proc == 0)
2456     panic("sleep");
2457 
2458   if(lk == 0)
2459     panic("sleep without lk");
2460 
2461   
2462   
2463   
2464   
2465   
2466   
2467   if(lk != &ptable.lock){  
2468     acquire(&ptable.lock);  
2469     release(lk);
2470   }
2471 
2472   
2473   proc->chan = chan;
2474   proc->state = SLEEPING;
2475   sched();
2476 
2477   
2478   proc->chan = 0;
2479 
2480   
2481   if(lk != &ptable.lock){  
2482     release(&ptable.lock);
2483     acquire(lk);
2484   }
2485 }
2486 
2487 
2488 
2489 static void
2490 wakeup1(void *chan)
2491 {
2492   struct proc *p;
2493 
2494   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2495     if(p->state == SLEEPING && p->chan == chan)
2496       p->state = RUNNABLE;
2497 }
2498 
2499 
2500 
2501 void
2502 wakeup(void *chan)
2503 {
2504   acquire(&ptable.lock);
2505   wakeup1(chan);
2506   release(&ptable.lock);
2507 }
2508 
2509 
2510 
2511 
2512 int
2513 kill(int pid)
2514 {
2515   struct proc *p;
2516 
2517   acquire(&ptable.lock);
2518   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2519     if(p->pid == pid){
2520       p->killed = 1;
2521       
2522       if(p->state == SLEEPING)
2523         p->state = RUNNABLE;
2524       release(&ptable.lock);
2525       return 0;
2526     }
2527   }
2528   release(&ptable.lock);
2529   return -1;
2530 }
2531 
2532 
2533 
2534 
2535 void
2536 procdump(void)
2537 {
2538   static char *states[] = {
2539   [UNUSED]    "unused",
2540   [EMBRYO]    "embryo",
2541   [SLEEPING]  "sleep ",
2542   [RUNNABLE]  "runble",
2543   [RUNNING]   "run   ",
2544   [ZOMBIE]    "zombie"
2545   };
2546   int i;
2547   struct proc *p;
2548   char *state;
2549   uint pc[10];
2550   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2551     if(p->state == UNUSED)
2552       continue;
2553     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
2554       state = states[p->state];
2555     else
2556       state = "???";
2557     cprintf("%d %s %s", p->pid, state, p->name);
2558     if(p->state == SLEEPING){
2559       getcallerpcs((uint*)p->context->ebp+2, pc);
2560       for(i=0; i<10 && pc[i] != 0; i++)
2561         cprintf(" %p", pc[i]);
2562     }
2563     cprintf("\n");
2564   }
2565 }
2566 
2567 
2568 
2569 
2570 
2571 
2572 
2573 
2574 
2575 
2576 
2577 
2578 
2579 
2580 
2581 
2582 
2583 
2584 
2585 
2586 
2587 
2588 
2589 
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 
2603 
2604 
2605 
2606 
2607 .globl swtch
2608 swtch:
2609   movl 4(%esp), %eax
2610   movl 8(%esp), %edx
2611 
2612   
2613   pushl %ebp
2614   pushl %ebx
2615   pushl %esi
2616   pushl %edi
2617 
2618   
2619   movl %esp, (%eax)
2620   movl %edx, %esp
2621 
2622   
2623   popl %edi
2624   popl %esi
2625   popl %ebx
2626   popl %ebp
2627   ret
2628 
2629 
2630 
2631 
2632 
2633 
2634 
2635 
2636 
2637 
2638 
2639 
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 
2654 #include "types.h"
2655 #include "defs.h"
2656 #include "param.h"
2657 #include "memlayout.h"
2658 #include "mmu.h"
2659 #include "spinlock.h"
2660 
2661 void freerange(void *vstart, void *vend);
2662 extern char end[]; 
2663 
2664 struct run {
2665   struct run *next;
2666 };
2667 
2668 struct {
2669   struct spinlock lock;
2670   int use_lock;
2671   struct run *freelist;
2672 } kmem;
2673 
2674 
2675 
2676 
2677 
2678 
2679 void
2680 kinit1(void *vstart, void *vend)
2681 {
2682   initlock(&kmem.lock, "kmem");
2683   kmem.use_lock = 0;
2684   freerange(vstart, vend);
2685 }
2686 
2687 void
2688 kinit2(void *vstart, void *vend)
2689 {
2690   freerange(vstart, vend);
2691   kmem.use_lock = 1;
2692 }
2693 
2694 
2695 
2696 
2697 
2698 
2699 
2700 void
2701 freerange(void *vstart, void *vend)
2702 {
2703   char *p;
2704   p = (char*)PGROUNDUP((uint)vstart);
2705   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
2706     kfree(p);
2707 }
2708 
2709 
2710 
2711 
2712 
2713 void
2714 kfree(char *v)
2715 {
2716   struct run *r;
2717 
2718   if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
2719     panic("kfree");
2720 
2721   
2722   memset(v, 1, PGSIZE);
2723 
2724   if(kmem.use_lock)
2725     acquire(&kmem.lock);
2726   r = (struct run*)v;
2727   r->next = kmem.freelist;
2728   kmem.freelist = r;
2729   if(kmem.use_lock)
2730     release(&kmem.lock);
2731 }
2732 
2733 
2734 
2735 
2736 char*
2737 kalloc(void)
2738 {
2739   struct run *r;
2740 
2741   if(kmem.use_lock)
2742     acquire(&kmem.lock);
2743   r = kmem.freelist;
2744   if(r)
2745     kmem.freelist = r->next;
2746   if(kmem.use_lock)
2747     release(&kmem.lock);
2748   return (char*)r;
2749 }
2750 
2751 
2752 
2753 #define T_DIVIDE         0      
2754 #define T_DEBUG          1      
2755 #define T_NMI            2      
2756 #define T_BRKPT          3      
2757 #define T_OFLOW          4      
2758 #define T_BOUND          5      
2759 #define T_ILLOP          6      
2760 #define T_DEVICE         7      
2761 #define T_DBLFLT         8      
2762 
2763 #define T_TSS           10      
2764 #define T_SEGNP         11      
2765 #define T_STACK         12      
2766 #define T_GPFLT         13      
2767 #define T_PGFLT         14      
2768 
2769 #define T_FPERR         16      
2770 #define T_ALIGN         17      
2771 #define T_MCHK          18      
2772 #define T_SIMDERR       19      
2773 
2774 
2775 
2776 #define T_SYSCALL       64      
2777 #define T_DEFAULT      500      
2778 
2779 #define T_IRQ0          32      
2780 
2781 #define IRQ_TIMER        0
2782 #define IRQ_KBD          1
2783 #define IRQ_COM1         4
2784 #define IRQ_IDE         14
2785 #define IRQ_ERROR       19
2786 #define IRQ_SPURIOUS    31
2787 
2788 
2789 
2790 
2791 
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 #!/usr/bin/perl -w
2801 
2802 # Generate vectors.S, the trap/interrupt entry points.
2803 # There has to be one entry point per interrupt number
2804 # since otherwise there's no way for trap() to discover
2805 # the interrupt number.
2806 
2807 print "# generated by vectors.pl - do not edit\n";
2808 print "# handlers\n";
2809 print ".globl alltraps\n";
2810 for(my $i = 0; $i < 256; $i++){
2811     print ".globl vector$i\n";
2812     print "vector$i:\n";
2813     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
2814         print "  pushl \$0\n";
2815     }
2816     print "  pushl \$$i\n";
2817     print "  jmp alltraps\n";
2818 }
2819 
2820 print "\n# vector table\n";
2821 print ".data\n";
2822 print ".globl vectors\n";
2823 print "vectors:\n";
2824 for(my $i = 0; $i < 256; $i++){
2825     print "  .long vector$i\n";
2826 }
2827 
2828 # sample output:
2829 #   # handlers
2830 #   .globl alltraps
2831 #   .globl vector0
2832 #   vector0:
2833 #     pushl $0
2834 #     pushl $0
2835 #     jmp alltraps
2836 #   ...
2837 #
2838 #   # vector table
2839 #   .data
2840 #   .globl vectors
2841 #   vectors:
2842 #     .long vector0
2843 #     .long vector1
2844 #     .long vector2
2845 #   ...
2846 
2847 
2848 
2849 
2850 
2851 
2852   
2853 .globl alltraps
2854 alltraps:
2855   
2856   pushl %ds
2857   pushl %es
2858   pushl %fs
2859   pushl %gs
2860   pushal
2861 
2862   
2863   movw $(SEG_KDATA<<3), %ax
2864   movw %ax, %ds
2865   movw %ax, %es
2866   movw $(SEG_KCPU<<3), %ax
2867   movw %ax, %fs
2868   movw %ax, %gs
2869 
2870   
2871   pushl %esp
2872   call trap
2873   addl $4, %esp
2874 
2875   
2876 .globl trapret
2877 trapret:
2878   popal
2879   popl %gs
2880   popl %fs
2881   popl %es
2882   popl %ds
2883   addl $0x8, %esp  
2884   iret
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 #include "types.h"
2901 #include "defs.h"
2902 #include "param.h"
2903 #include "memlayout.h"
2904 #include "mmu.h"
2905 #include "proc.h"
2906 #include "x86.h"
2907 #include "traps.h"
2908 #include "spinlock.h"
2909 
2910 
2911 struct gatedesc idt[256];
2912 extern uint vectors[];  
2913 struct spinlock tickslock;
2914 uint ticks;
2915 
2916 void
2917 tvinit(void)
2918 {
2919   int i;
2920 
2921   for(i = 0; i < 256; i++)
2922     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
2923   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
2924 
2925   initlock(&tickslock, "time");
2926 }
2927 
2928 void
2929 idtinit(void)
2930 {
2931   lidt(idt, sizeof(idt));
2932 }
2933 
2934 void
2935 trap(struct trapframe *tf)
2936 {
2937   if(tf->trapno == T_SYSCALL){
2938     if(proc->killed)
2939       exit();
2940     proc->tf = tf;
2941     syscall();
2942     if(proc->killed)
2943       exit();
2944     return;
2945   }
2946 
2947   switch(tf->trapno){
2948   case T_IRQ0 + IRQ_TIMER:
2949     if(cpu->id == 0){
2950       acquire(&tickslock);
2951       ticks++;
2952       wakeup(&ticks);
2953       release(&tickslock);
2954     }
2955     lapiceoi();
2956     break;
2957   case T_IRQ0 + IRQ_IDE:
2958     ideintr();
2959     lapiceoi();
2960     break;
2961   case T_IRQ0 + IRQ_IDE+1:
2962     
2963     break;
2964   case T_IRQ0 + IRQ_KBD:
2965     kbdintr();
2966     lapiceoi();
2967     break;
2968   case T_IRQ0 + IRQ_COM1:
2969     uartintr();
2970     lapiceoi();
2971     break;
2972   case T_IRQ0 + 7:
2973   case T_IRQ0 + IRQ_SPURIOUS:
2974     cprintf("cpu%d: spurious interrupt at %x:%x\n",
2975             cpu->id, tf->cs, tf->eip);
2976     lapiceoi();
2977     break;
2978 
2979   default:
2980     if(proc == 0 || (tf->cs&3) == 0){
2981       
2982       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
2983               tf->trapno, cpu->id, tf->eip, rcr2());
2984       panic("trap");
2985     }
2986     
2987     cprintf("pid %d %s: trap %d err %d on cpu %d "
2988             "eip 0x%x addr 0x%x--kill proc\n",
2989             proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
2990             rcr2());
2991     proc->killed = 1;
2992   }
2993 
2994   
2995   
2996   
2997   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
2998     exit();
2999 
3000   
3001   
3002   if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
3003     yield();
3004 
3005   
3006   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3007     exit();
3008 }
3009 
3010 
3011 
3012 
3013 
3014 
3015 
3016 
3017 
3018 
3019 
3020 
3021 
3022 
3023 
3024 
3025 
3026 
3027 
3028 
3029 
3030 
3031 
3032 
3033 
3034 
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 #define SYS_fork    1
3052 #define SYS_exit    2
3053 #define SYS_wait    3
3054 #define SYS_pipe    4
3055 #define SYS_read    5
3056 #define SYS_kill    6
3057 #define SYS_exec    7
3058 #define SYS_fstat   8
3059 #define SYS_chdir   9
3060 #define SYS_dup    10
3061 #define SYS_getpid 11
3062 #define SYS_sbrk   12
3063 #define SYS_sleep  13
3064 #define SYS_uptime 14
3065 #define SYS_open   15
3066 #define SYS_write  16
3067 #define SYS_mknod  17
3068 #define SYS_unlink 18
3069 #define SYS_link   19
3070 #define SYS_mkdir  20
3071 #define SYS_close  21
3072 
3073 
3074 
3075 
3076 
3077 
3078 
3079 
3080 
3081 
3082 
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 #include "types.h"
3101 #include "defs.h"
3102 #include "param.h"
3103 #include "memlayout.h"
3104 #include "mmu.h"
3105 #include "proc.h"
3106 #include "x86.h"
3107 #include "syscall.h"
3108 
3109 
3110 
3111 
3112 
3113 
3114 
3115 
3116 int
3117 fetchint(uint addr, int *ip)
3118 {
3119   if(addr >= proc->sz || addr+4 > proc->sz)
3120     return -1;
3121   *ip = *(int*)(addr);
3122   return 0;
3123 }
3124 
3125 
3126 
3127 
3128 int
3129 fetchstr(uint addr, char **pp)
3130 {
3131   char *s, *ep;
3132 
3133   if(addr >= proc->sz)
3134     return -1;
3135   *pp = (char*)addr;
3136   ep = (char*)proc->sz;
3137   for(s = *pp; s < ep; s++)
3138     if(*s == 0)
3139       return s - *pp;
3140   return -1;
3141 }
3142 
3143 
3144 int
3145 argint(int n, int *ip)
3146 {
3147   return fetchint(proc->tf->esp + 4 + 4*n, ip);
3148 }
3149 
3150 
3151 
3152 
3153 int
3154 argptr(int n, char **pp, int size)
3155 {
3156   int i;
3157 
3158   if(argint(n, &i) < 0)
3159     return -1;
3160   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
3161     return -1;
3162   *pp = (char*)i;
3163   return 0;
3164 }
3165 
3166 
3167 
3168 
3169 
3170 int
3171 argstr(int n, char **pp)
3172 {
3173   int addr;
3174   if(argint(n, &addr) < 0)
3175     return -1;
3176   return fetchstr(addr, pp);
3177 }
3178 
3179 extern int sys_chdir(void);
3180 extern int sys_close(void);
3181 extern int sys_dup(void);
3182 extern int sys_exec(void);
3183 extern int sys_exit(void);
3184 extern int sys_fork(void);
3185 extern int sys_fstat(void);
3186 extern int sys_getpid(void);
3187 extern int sys_kill(void);
3188 extern int sys_link(void);
3189 extern int sys_mkdir(void);
3190 extern int sys_mknod(void);
3191 extern int sys_open(void);
3192 extern int sys_pipe(void);
3193 extern int sys_read(void);
3194 extern int sys_sbrk(void);
3195 extern int sys_sleep(void);
3196 extern int sys_unlink(void);
3197 extern int sys_wait(void);
3198 extern int sys_write(void);
3199 extern int sys_uptime(void);
3200 static int (*syscalls[])(void) = {
3201 [SYS_fork]    sys_fork,
3202 [SYS_exit]    sys_exit,
3203 [SYS_wait]    sys_wait,
3204 [SYS_pipe]    sys_pipe,
3205 [SYS_read]    sys_read,
3206 [SYS_kill]    sys_kill,
3207 [SYS_exec]    sys_exec,
3208 [SYS_fstat]   sys_fstat,
3209 [SYS_chdir]   sys_chdir,
3210 [SYS_dup]     sys_dup,
3211 [SYS_getpid]  sys_getpid,
3212 [SYS_sbrk]    sys_sbrk,
3213 [SYS_sleep]   sys_sleep,
3214 [SYS_uptime]  sys_uptime,
3215 [SYS_open]    sys_open,
3216 [SYS_write]   sys_write,
3217 [SYS_mknod]   sys_mknod,
3218 [SYS_unlink]  sys_unlink,
3219 [SYS_link]    sys_link,
3220 [SYS_mkdir]   sys_mkdir,
3221 [SYS_close]   sys_close,
3222 };
3223 
3224 void
3225 syscall(void)
3226 {
3227   int num;
3228 
3229   num = proc->tf->eax;
3230   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3231     proc->tf->eax = syscalls[num]();
3232   } else {
3233     cprintf("%d %s: unknown sys call %d\n",
3234             proc->pid, proc->name, num);
3235     proc->tf->eax = -1;
3236   }
3237 }
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 #include "types.h"
3251 #include "x86.h"
3252 #include "defs.h"
3253 #include "date.h"
3254 #include "param.h"
3255 #include "memlayout.h"
3256 #include "mmu.h"
3257 #include "proc.h"
3258 
3259 int
3260 sys_fork(void)
3261 {
3262   return fork();
3263 }
3264 
3265 int
3266 sys_exit(void)
3267 {
3268   exit();
3269   return 0;  
3270 }
3271 
3272 int
3273 sys_wait(void)
3274 {
3275   return wait();
3276 }
3277 
3278 int
3279 sys_kill(void)
3280 {
3281   int pid;
3282 
3283   if(argint(0, &pid) < 0)
3284     return -1;
3285   return kill(pid);
3286 }
3287 
3288 int
3289 sys_getpid(void)
3290 {
3291   return proc->pid;
3292 }
3293 
3294 
3295 
3296 
3297 
3298 
3299 
3300 int
3301 sys_sbrk(void)
3302 {
3303   int addr;
3304   int n;
3305 
3306   if(argint(0, &n) < 0)
3307     return -1;
3308   addr = proc->sz;
3309   if(growproc(n) < 0)
3310     return -1;
3311   return addr;
3312 }
3313 
3314 int
3315 sys_sleep(void)
3316 {
3317   int n;
3318   uint ticks0;
3319 
3320   if(argint(0, &n) < 0)
3321     return -1;
3322   acquire(&tickslock);
3323   ticks0 = ticks;
3324   while(ticks - ticks0 < n){
3325     if(proc->killed){
3326       release(&tickslock);
3327       return -1;
3328     }
3329     sleep(&ticks, &tickslock);
3330   }
3331   release(&tickslock);
3332   return 0;
3333 }
3334 
3335 
3336 
3337 int
3338 sys_uptime(void)
3339 {
3340   uint xticks;
3341 
3342   acquire(&tickslock);
3343   xticks = ticks;
3344   release(&tickslock);
3345   return xticks;
3346 }
3347 
3348 
3349 
3350 struct buf {
3351   int flags;
3352   uint dev;
3353   uint blockno;
3354   struct buf *prev; 
3355   struct buf *next;
3356   struct buf *qnext; 
3357   uchar data[BSIZE];
3358 };
3359 #define B_BUSY  0x1  
3360 #define B_VALID 0x2  
3361 #define B_DIRTY 0x4  
3362 
3363 
3364 
3365 
3366 
3367 
3368 
3369 
3370 
3371 
3372 
3373 
3374 
3375 
3376 
3377 
3378 
3379 
3380 
3381 
3382 
3383 
3384 
3385 
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 #define O_RDONLY  0x000
3401 #define O_WRONLY  0x001
3402 #define O_RDWR    0x002
3403 #define O_CREATE  0x200
3404 
3405 
3406 
3407 
3408 
3409 
3410 
3411 
3412 
3413 
3414 
3415 
3416 
3417 
3418 
3419 
3420 
3421 
3422 
3423 
3424 
3425 
3426 
3427 
3428 
3429 
3430 
3431 
3432 
3433 
3434 
3435 
3436 
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 #define T_DIR  1   
3451 #define T_FILE 2   
3452 #define T_DEV  3   
3453 
3454 struct stat {
3455   short type;  
3456   int dev;     
3457   uint ino;    
3458   short nlink; 
3459   uint size;   
3460 };
3461 
3462 
3463 
3464 
3465 
3466 
3467 
3468 
3469 
3470 
3471 
3472 
3473 
3474 
3475 
3476 
3477 
3478 
3479 
3480 
3481 
3482 
3483 
3484 
3485 
3486 
3487 
3488 
3489 
3490 
3491 
3492 
3493 
3494 
3495 
3496 
3497 
3498 
3499 
3500 
3501 
3502 
3503 
3504 #define ROOTINO 1  
3505 #define BSIZE 512  
3506 
3507 
3508 
3509 
3510 
3511 
3512 struct superblock {
3513   uint size;         
3514   uint nblocks;      
3515   uint ninodes;      
3516   uint nlog;         
3517   uint logstart;     
3518   uint inodestart;   
3519   uint bmapstart;    
3520 };
3521 
3522 #define NDIRECT 12
3523 #define NINDIRECT (BSIZE / sizeof(uint))
3524 #define MAXFILE (NDIRECT + NINDIRECT)
3525 
3526 
3527 struct dinode {
3528   short type;           
3529   short major;          
3530   short minor;          
3531   short nlink;          
3532   uint size;            
3533   uint addrs[NDIRECT+1];   
3534 };
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 
3551 #define IPB           (BSIZE / sizeof(struct dinode))
3552 
3553 
3554 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
3555 
3556 
3557 #define BPB           (BSIZE*8)
3558 
3559 
3560 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
3561 
3562 
3563 #define DIRSIZ 14
3564 
3565 struct dirent {
3566   ushort inum;
3567   char name[DIRSIZ];
3568 };
3569 
3570 
3571 
3572 
3573 
3574 
3575 
3576 
3577 
3578 
3579 
3580 
3581 
3582 
3583 
3584 
3585 
3586 
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 struct file {
3601   enum { FD_NONE, FD_PIPE, FD_INODE } type;
3602   int ref; 
3603   char readable;
3604   char writable;
3605   struct pipe *pipe;
3606   struct inode *ip;
3607   uint off;
3608 };
3609 
3610 
3611 
3612 struct inode {
3613   uint dev;           
3614   uint inum;          
3615   int ref;            
3616   int flags;          
3617 
3618   short type;         
3619   short major;
3620   short minor;
3621   short nlink;
3622   uint size;
3623   uint addrs[NDIRECT+1];
3624 };
3625 #define I_BUSY 0x1
3626 #define I_VALID 0x2
3627 
3628 
3629 
3630 struct devsw {
3631   int (*read)(struct inode*, char*, int);
3632   int (*write)(struct inode*, char*, int);
3633 };
3634 
3635 extern struct devsw devsw[];
3636 
3637 #define CONSOLE 1
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 
3651 
3652 #include "types.h"
3653 #include "defs.h"
3654 #include "param.h"
3655 #include "memlayout.h"
3656 #include "mmu.h"
3657 #include "proc.h"
3658 #include "x86.h"
3659 #include "traps.h"
3660 #include "spinlock.h"
3661 #include "fs.h"
3662 #include "buf.h"
3663 
3664 #define SECTOR_SIZE   512
3665 #define IDE_BSY       0x80
3666 #define IDE_DRDY      0x40
3667 #define IDE_DF        0x20
3668 #define IDE_ERR       0x01
3669 
3670 #define IDE_CMD_READ  0x20
3671 #define IDE_CMD_WRITE 0x30
3672 
3673 
3674 
3675 
3676 
3677 static struct spinlock idelock;
3678 static struct buf *idequeue;
3679 
3680 static int havedisk1;
3681 static void idestart(struct buf*);
3682 
3683 
3684 static int
3685 idewait(int checkerr)
3686 {
3687   int r;
3688 
3689   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
3690     ;
3691   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
3692     return -1;
3693   return 0;
3694 }
3695 
3696 
3697 
3698 
3699 
3700 void
3701 ideinit(void)
3702 {
3703   int i;
3704 
3705   initlock(&idelock, "ide");
3706   picenable(IRQ_IDE);
3707   ioapicenable(IRQ_IDE, ncpu - 1);
3708   idewait(0);
3709 
3710   
3711   outb(0x1f6, 0xe0 | (1<<4));
3712   for(i=0; i<1000; i++){
3713     if(inb(0x1f7) != 0){
3714       havedisk1 = 1;
3715       break;
3716     }
3717   }
3718 
3719   
3720   outb(0x1f6, 0xe0 | (0<<4));
3721 }
3722 
3723 
3724 static void
3725 idestart(struct buf *b)
3726 {
3727   if(b == 0)
3728     panic("idestart");
3729   if(b->blockno >= FSSIZE)
3730     panic("incorrect blockno");
3731   int sector_per_block =  BSIZE/SECTOR_SIZE;
3732   int sector = b->blockno * sector_per_block;
3733 
3734   if (sector_per_block > 7) panic("idestart");
3735 
3736   idewait(0);
3737   outb(0x3f6, 0);  
3738   outb(0x1f2, sector_per_block);  
3739   outb(0x1f3, sector & 0xff);
3740   outb(0x1f4, (sector >> 8) & 0xff);
3741   outb(0x1f5, (sector >> 16) & 0xff);
3742   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
3743   if(b->flags & B_DIRTY){
3744     outb(0x1f7, IDE_CMD_WRITE);
3745     outsl(0x1f0, b->data, BSIZE/4);
3746   } else {
3747     outb(0x1f7, IDE_CMD_READ);
3748   }
3749 }
3750 
3751 void
3752 ideintr(void)
3753 {
3754   struct buf *b;
3755 
3756   
3757   acquire(&idelock);
3758   if((b = idequeue) == 0){
3759     release(&idelock);
3760     
3761     return;
3762   }
3763   idequeue = b->qnext;
3764 
3765   
3766   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
3767     insl(0x1f0, b->data, BSIZE/4);
3768 
3769   
3770   b->flags |= B_VALID;
3771   b->flags &= ~B_DIRTY;
3772   wakeup(b);
3773 
3774   
3775   if(idequeue != 0)
3776     idestart(idequeue);
3777 
3778   release(&idelock);
3779 }
3780 
3781 
3782 
3783 
3784 void
3785 iderw(struct buf *b)
3786 {
3787   struct buf **pp;
3788 
3789   if(!(b->flags & B_BUSY))
3790     panic("iderw: buf not busy");
3791   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
3792     panic("iderw: nothing to do");
3793   if(b->dev != 0 && !havedisk1)
3794     panic("iderw: ide disk 1 not present");
3795 
3796   acquire(&idelock);  
3797 
3798 
3799 
3800   
3801   b->qnext = 0;
3802   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
3803     ;
3804   *pp = b;
3805 
3806   
3807   if(idequeue == b)
3808     idestart(b);
3809 
3810   
3811   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
3812     sleep(b, &idelock);
3813   }
3814 
3815   release(&idelock);
3816 }
3817 
3818 
3819 
3820 
3821 
3822 
3823 
3824 
3825 
3826 
3827 
3828 
3829 
3830 
3831 
3832 
3833 
3834 
3835 
3836 
3837 
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 
3851 
3852 
3853 
3854 
3855 
3856 
3857 
3858 
3859 
3860 
3861 
3862 
3863 
3864 
3865 
3866 
3867 
3868 
3869 
3870 
3871 
3872 #include "types.h"
3873 #include "defs.h"
3874 #include "param.h"
3875 #include "spinlock.h"
3876 #include "fs.h"
3877 #include "buf.h"
3878 
3879 struct {
3880   struct spinlock lock;
3881   struct buf buf[NBUF];
3882 
3883   
3884   
3885   struct buf head;
3886 } bcache;
3887 
3888 void
3889 binit(void)
3890 {
3891   struct buf *b;
3892 
3893   initlock(&bcache.lock, "bcache");
3894 
3895   
3896   bcache.head.prev = &bcache.head;
3897   bcache.head.next = &bcache.head;
3898   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
3899     b->next = bcache.head.next;
3900     b->prev = &bcache.head;
3901     b->dev = -1;
3902     bcache.head.next->prev = b;
3903     bcache.head.next = b;
3904   }
3905 }
3906 
3907 
3908 
3909 
3910 static struct buf*
3911 bget(uint dev, uint blockno)
3912 {
3913   struct buf *b;
3914 
3915   acquire(&bcache.lock);
3916 
3917  loop:
3918   
3919   for(b = bcache.head.next; b != &bcache.head; b = b->next){
3920     if(b->dev == dev && b->blockno == blockno){
3921       if(!(b->flags & B_BUSY)){
3922         b->flags |= B_BUSY;
3923         release(&bcache.lock);
3924         return b;
3925       }
3926       sleep(b, &bcache.lock);
3927       goto loop;
3928     }
3929   }
3930 
3931   
3932   
3933   
3934   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
3935     if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
3936       b->dev = dev;
3937       b->blockno = blockno;
3938       b->flags = B_BUSY;
3939       release(&bcache.lock);
3940       return b;
3941     }
3942   }
3943   panic("bget: no buffers");
3944 }
3945 
3946 
3947 
3948 
3949 
3950 
3951 struct buf*
3952 bread(uint dev, uint blockno)
3953 {
3954   struct buf *b;
3955 
3956   b = bget(dev, blockno);
3957   if(!(b->flags & B_VALID)) {
3958     iderw(b);
3959   }
3960   return b;
3961 }
3962 
3963 
3964 void
3965 bwrite(struct buf *b)
3966 {
3967   if((b->flags & B_BUSY) == 0)
3968     panic("bwrite");
3969   b->flags |= B_DIRTY;
3970   iderw(b);
3971 }
3972 
3973 
3974 
3975 void
3976 brelse(struct buf *b)
3977 {
3978   if((b->flags & B_BUSY) == 0)
3979     panic("brelse");
3980 
3981   acquire(&bcache.lock);
3982 
3983   b->next->prev = b->prev;
3984   b->prev->next = b->next;
3985   b->next = bcache.head.next;
3986   b->prev = &bcache.head;
3987   bcache.head.next->prev = b;
3988   bcache.head.next = b;
3989 
3990   b->flags &= ~B_BUSY;
3991   wakeup(b);
3992 
3993   release(&bcache.lock);
3994 }
3995 
3996 
3997 
3998 
3999 
4000 #include "types.h"
4001 #include "defs.h"
4002 #include "param.h"
4003 #include "spinlock.h"
4004 #include "fs.h"
4005 #include "buf.h"
4006 
4007 
4008 
4009 
4010 
4011 
4012 
4013 
4014 
4015 
4016 
4017 
4018 
4019 
4020 
4021 
4022 
4023 
4024 
4025 
4026 
4027 
4028 
4029 
4030 
4031 
4032 struct logheader {
4033   int n;
4034   int block[LOGSIZE];
4035 };
4036 
4037 struct log {
4038   struct spinlock lock;
4039   int start;
4040   int size;
4041   int outstanding; 
4042   int committing;  
4043   int dev;
4044   struct logheader lh;
4045 };
4046 
4047 
4048 
4049 
4050 struct log log;
4051 
4052 static void recover_from_log(void);
4053 static void commit();
4054 
4055 void
4056 initlog(int dev)
4057 {
4058   if (sizeof(struct logheader) >= BSIZE)
4059     panic("initlog: too big logheader");
4060 
4061   struct superblock sb;
4062   initlock(&log.lock, "log");
4063   readsb(dev, &sb);
4064   log.start = sb.logstart;
4065   log.size = sb.nlog;
4066   log.dev = dev;
4067   recover_from_log();
4068 }
4069 
4070 
4071 static void
4072 install_trans(void)
4073 {
4074   int tail;
4075 
4076   for (tail = 0; tail < log.lh.n; tail++) {
4077     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4078     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4079     memmove(dbuf->data, lbuf->data, BSIZE);  
4080     bwrite(dbuf);  
4081     brelse(lbuf);
4082     brelse(dbuf);
4083   }
4084 }
4085 
4086 
4087 static void
4088 read_head(void)
4089 {
4090   struct buf *buf = bread(log.dev, log.start);
4091   struct logheader *lh = (struct logheader *) (buf->data);
4092   int i;
4093   log.lh.n = lh->n;
4094   for (i = 0; i < log.lh.n; i++) {
4095     log.lh.block[i] = lh->block[i];
4096   }
4097   brelse(buf);
4098 }
4099 
4100 
4101 
4102 
4103 static void
4104 write_head(void)
4105 {
4106   struct buf *buf = bread(log.dev, log.start);
4107   struct logheader *hb = (struct logheader *) (buf->data);
4108   int i;
4109   hb->n = log.lh.n;
4110   for (i = 0; i < log.lh.n; i++) {
4111     hb->block[i] = log.lh.block[i];
4112   }
4113   bwrite(buf);
4114   brelse(buf);
4115 }
4116 
4117 static void
4118 recover_from_log(void)
4119 {
4120   read_head();
4121   install_trans(); 
4122   log.lh.n = 0;
4123   write_head(); 
4124 }
4125 
4126 
4127 void
4128 begin_op(void)
4129 {
4130   acquire(&log.lock);
4131   while(1){
4132     if(log.committing){
4133       sleep(&log, &log.lock);
4134     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4135       
4136       sleep(&log, &log.lock);
4137     } else {
4138       log.outstanding += 1;
4139       release(&log.lock);
4140       break;
4141     }
4142   }
4143 }
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 
4152 void
4153 end_op(void)
4154 {
4155   int do_commit = 0;
4156 
4157   acquire(&log.lock);
4158   log.outstanding -= 1;
4159   if(log.committing)
4160     panic("log.committing");
4161   if(log.outstanding == 0){
4162     do_commit = 1;
4163     log.committing = 1;
4164   } else {
4165     
4166     wakeup(&log);
4167   }
4168   release(&log.lock);
4169 
4170   if(do_commit){
4171     
4172     
4173     commit();
4174     acquire(&log.lock);
4175     log.committing = 0;
4176     wakeup(&log);
4177     release(&log.lock);
4178   }
4179 }
4180 
4181 
4182 static void
4183 write_log(void)
4184 {
4185   int tail;
4186 
4187   for (tail = 0; tail < log.lh.n; tail++) {
4188     struct buf *to = bread(log.dev, log.start+tail+1); 
4189     struct buf *from = bread(log.dev, log.lh.block[tail]); 
4190     memmove(to->data, from->data, BSIZE);
4191     bwrite(to);  
4192     brelse(from);
4193     brelse(to);
4194   }
4195 }
4196 
4197 
4198 
4199 
4200 static void
4201 commit()
4202 {
4203   if (log.lh.n > 0) {
4204     write_log();     
4205     write_head();    
4206     install_trans(); 
4207     log.lh.n = 0;
4208     write_head();    
4209   }
4210 }
4211 
4212 
4213 
4214 
4215 
4216 
4217 
4218 
4219 
4220 
4221 void
4222 log_write(struct buf *b)
4223 {
4224   int i;
4225 
4226   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4227     panic("too big a transaction");
4228   if (log.outstanding < 1)
4229     panic("log_write outside of trans");
4230 
4231   acquire(&log.lock);
4232   for (i = 0; i < log.lh.n; i++) {
4233     if (log.lh.block[i] == b->blockno)   
4234       break;
4235   }
4236   log.lh.block[i] = b->blockno;
4237   if (i == log.lh.n)
4238     log.lh.n++;
4239   b->flags |= B_DIRTY; 
4240   release(&log.lock);
4241 }
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 
4251 
4252 
4253 
4254 
4255 
4256 
4257 
4258 
4259 
4260 
4261 #include "types.h"
4262 #include "defs.h"
4263 #include "param.h"
4264 #include "stat.h"
4265 #include "mmu.h"
4266 #include "proc.h"
4267 #include "spinlock.h"
4268 #include "fs.h"
4269 #include "buf.h"
4270 #include "file.h"
4271 
4272 #define min(a, b) ((a) < (b) ? (a) : (b))
4273 static void itrunc(struct inode*);
4274 struct superblock sb;   
4275 
4276 
4277 void
4278 readsb(int dev, struct superblock *sb)
4279 {
4280   struct buf *bp;
4281 
4282   bp = bread(dev, 1);
4283   memmove(sb, bp->data, sizeof(*sb));
4284   brelse(bp);
4285 }
4286 
4287 
4288 static void
4289 bzero(int dev, int bno)
4290 {
4291   struct buf *bp;
4292 
4293   bp = bread(dev, bno);
4294   memset(bp->data, 0, BSIZE);
4295   log_write(bp);
4296   brelse(bp);
4297 }
4298 
4299 
4300 
4301 
4302 
4303 static uint
4304 balloc(uint dev)
4305 {
4306   int b, bi, m;
4307   struct buf *bp;
4308 
4309   bp = 0;
4310   for(b = 0; b < sb.size; b += BPB){
4311     bp = bread(dev, BBLOCK(b, sb));
4312     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
4313       m = 1 << (bi % 8);
4314       if((bp->data[bi/8] & m) == 0){  
4315         bp->data[bi/8] |= m;  
4316         log_write(bp);
4317         brelse(bp);
4318         bzero(dev, b + bi);
4319         return b + bi;
4320       }
4321     }
4322     brelse(bp);
4323   }
4324   panic("balloc: out of blocks");
4325 }
4326 
4327 
4328 static void
4329 bfree(int dev, uint b)
4330 {
4331   struct buf *bp;
4332   int bi, m;
4333 
4334   readsb(dev, &sb);
4335   bp = bread(dev, BBLOCK(b, sb));
4336   bi = b % BPB;
4337   m = 1 << (bi % 8);
4338   if((bp->data[bi/8] & m) == 0)
4339     panic("freeing free block");
4340   bp->data[bi/8] &= ~m;
4341   log_write(bp);
4342   brelse(bp);
4343 }
4344 
4345 
4346 
4347 
4348 
4349 
4350 
4351 
4352 
4353 
4354 
4355 
4356 
4357 
4358 
4359 
4360 
4361 
4362 
4363 
4364 
4365 
4366 
4367 
4368 
4369 
4370 
4371 
4372 
4373 
4374 
4375 
4376 
4377 
4378 
4379 
4380 
4381 
4382 
4383 
4384 
4385 
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 
4401 
4402 
4403 
4404 
4405 
4406 
4407 
4408 
4409 
4410 
4411 
4412 struct {
4413   struct spinlock lock;
4414   struct inode inode[NINODE];
4415 } icache;
4416 
4417 void
4418 iinit(int dev)
4419 {
4420   initlock(&icache.lock, "icache");
4421   readsb(dev, &sb);
4422   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
4423           sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
4424 }
4425 
4426 static struct inode* iget(uint dev, uint inum);
4427 
4428 
4429 
4430 struct inode*
4431 ialloc(uint dev, short type)
4432 {
4433   int inum;
4434   struct buf *bp;
4435   struct dinode *dip;
4436 
4437   for(inum = 1; inum < sb.ninodes; inum++){
4438     bp = bread(dev, IBLOCK(inum, sb));
4439     dip = (struct dinode*)bp->data + inum%IPB;
4440     if(dip->type == 0){  
4441       memset(dip, 0, sizeof(*dip));
4442       dip->type = type;
4443       log_write(bp);   
4444       brelse(bp);
4445       return iget(dev, inum);
4446     }
4447     brelse(bp);
4448   }
4449   panic("ialloc: no inodes");
4450 }
4451 
4452 
4453 void
4454 iupdate(struct inode *ip)
4455 {
4456   struct buf *bp;
4457   struct dinode *dip;
4458 
4459   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
4460   dip = (struct dinode*)bp->data + ip->inum%IPB;
4461   dip->type = ip->type;
4462   dip->major = ip->major;
4463   dip->minor = ip->minor;
4464   dip->nlink = ip->nlink;
4465   dip->size = ip->size;
4466   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
4467   log_write(bp);
4468   brelse(bp);
4469 }
4470 
4471 
4472 
4473 
4474 static struct inode*
4475 iget(uint dev, uint inum)
4476 {
4477   struct inode *ip, *empty;
4478 
4479   acquire(&icache.lock);
4480 
4481   
4482   empty = 0;
4483   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
4484     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
4485       ip->ref++;
4486       release(&icache.lock);
4487       return ip;
4488     }
4489     if(empty == 0 && ip->ref == 0)    
4490       empty = ip;
4491   }
4492 
4493   
4494   if(empty == 0)
4495     panic("iget: no inodes");
4496 
4497 
4498 
4499 
4500   ip = empty;
4501   ip->dev = dev;
4502   ip->inum = inum;
4503   ip->ref = 1;
4504   ip->flags = 0;
4505   release(&icache.lock);
4506 
4507   return ip;
4508 }
4509 
4510 
4511 
4512 struct inode*
4513 idup(struct inode *ip)
4514 {
4515   acquire(&icache.lock);
4516   ip->ref++;
4517   release(&icache.lock);
4518   return ip;
4519 }
4520 
4521 
4522 
4523 void
4524 ilock(struct inode *ip)
4525 {
4526   struct buf *bp;
4527   struct dinode *dip;
4528 
4529   if(ip == 0 || ip->ref < 1)
4530     panic("ilock");
4531 
4532   acquire(&icache.lock);
4533   while(ip->flags & I_BUSY)
4534     sleep(ip, &icache.lock);
4535   ip->flags |= I_BUSY;
4536   release(&icache.lock);
4537 
4538   if(!(ip->flags & I_VALID)){
4539     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
4540     dip = (struct dinode*)bp->data + ip->inum%IPB;
4541     ip->type = dip->type;
4542     ip->major = dip->major;
4543     ip->minor = dip->minor;
4544     ip->nlink = dip->nlink;
4545     ip->size = dip->size;
4546     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
4547     brelse(bp);
4548     ip->flags |= I_VALID;
4549     if(ip->type == 0)
4550       panic("ilock: no type");
4551   }
4552 }
4553 
4554 
4555 void
4556 iunlock(struct inode *ip)
4557 {
4558   if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
4559     panic("iunlock");
4560 
4561   acquire(&icache.lock);
4562   ip->flags &= ~I_BUSY;
4563   wakeup(ip);
4564   release(&icache.lock);
4565 }
4566 
4567 
4568 
4569 
4570 
4571 
4572 
4573 
4574 void
4575 iput(struct inode *ip)
4576 {
4577   acquire(&icache.lock);
4578   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
4579     
4580     if(ip->flags & I_BUSY)
4581       panic("iput busy");
4582     ip->flags |= I_BUSY;
4583     release(&icache.lock);
4584     itrunc(ip);
4585     ip->type = 0;
4586     iupdate(ip);
4587     acquire(&icache.lock);
4588     ip->flags = 0;
4589     wakeup(ip);
4590   }
4591   ip->ref--;
4592   release(&icache.lock);
4593 }
4594 
4595 
4596 
4597 
4598 
4599 
4600 
4601 void
4602 iunlockput(struct inode *ip)
4603 {
4604   iunlock(ip);
4605   iput(ip);
4606 }
4607 
4608 
4609 
4610 
4611 
4612 
4613 
4614 
4615 
4616 
4617 static uint
4618 bmap(struct inode *ip, uint bn)
4619 {
4620   uint addr, *a;
4621   struct buf *bp;
4622 
4623   if(bn < NDIRECT){
4624     if((addr = ip->addrs[bn]) == 0)
4625       ip->addrs[bn] = addr = balloc(ip->dev);
4626     return addr;
4627   }
4628   bn -= NDIRECT;
4629 
4630   if(bn < NINDIRECT){
4631     
4632     if((addr = ip->addrs[NDIRECT]) == 0)
4633       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
4634     bp = bread(ip->dev, addr);
4635     a = (uint*)bp->data;
4636     if((addr = a[bn]) == 0){
4637       a[bn] = addr = balloc(ip->dev);
4638       log_write(bp);
4639     }
4640     brelse(bp);
4641     return addr;
4642   }
4643 
4644   panic("bmap: out of range");
4645 }
4646 
4647 
4648 
4649 
4650 
4651 
4652 
4653 
4654 
4655 static void
4656 itrunc(struct inode *ip)
4657 {
4658   int i, j;
4659   struct buf *bp;
4660   uint *a;
4661 
4662   for(i = 0; i < NDIRECT; i++){
4663     if(ip->addrs[i]){
4664       bfree(ip->dev, ip->addrs[i]);
4665       ip->addrs[i] = 0;
4666     }
4667   }
4668 
4669   if(ip->addrs[NDIRECT]){
4670     bp = bread(ip->dev, ip->addrs[NDIRECT]);
4671     a = (uint*)bp->data;
4672     for(j = 0; j < NINDIRECT; j++){
4673       if(a[j])
4674         bfree(ip->dev, a[j]);
4675     }
4676     brelse(bp);
4677     bfree(ip->dev, ip->addrs[NDIRECT]);
4678     ip->addrs[NDIRECT] = 0;
4679   }
4680 
4681   ip->size = 0;
4682   iupdate(ip);
4683 }
4684 
4685 
4686 void
4687 stati(struct inode *ip, struct stat *st)
4688 {
4689   st->dev = ip->dev;
4690   st->ino = ip->inum;
4691   st->type = ip->type;
4692   st->nlink = ip->nlink;
4693   st->size = ip->size;
4694 }
4695 
4696 
4697 
4698 
4699 
4700 
4701 int
4702 readi(struct inode *ip, char *dst, uint off, uint n)
4703 {
4704   uint tot, m;
4705   struct buf *bp;
4706 
4707   if(ip->type == T_DEV){
4708     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
4709       return -1;
4710     return devsw[ip->major].read(ip, dst, n);
4711   }
4712 
4713   if(off > ip->size || off + n < off)
4714     return -1;
4715   if(off + n > ip->size)
4716     n = ip->size - off;
4717 
4718   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
4719     bp = bread(ip->dev, bmap(ip, off/BSIZE));
4720     m = min(n - tot, BSIZE - off%BSIZE);
4721     memmove(dst, bp->data + off%BSIZE, m);
4722     brelse(bp);
4723   }
4724   return n;
4725 }
4726 
4727 
4728 int
4729 writei(struct inode *ip, char *src, uint off, uint n)
4730 {
4731   uint tot, m;
4732   struct buf *bp;
4733 
4734   if(ip->type == T_DEV){
4735     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
4736       return -1;
4737     return devsw[ip->major].write(ip, src, n);
4738   }
4739 
4740   if(off > ip->size || off + n < off)
4741     return -1;
4742   if(off + n > MAXFILE*BSIZE)
4743     return -1;
4744 
4745   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
4746     bp = bread(ip->dev, bmap(ip, off/BSIZE));
4747     m = min(n - tot, BSIZE - off%BSIZE);
4748     memmove(bp->data + off%BSIZE, src, m);
4749     log_write(bp);
4750     brelse(bp);
4751   }
4752 
4753   if(n > 0 && off > ip->size){
4754     ip->size = off;
4755     iupdate(ip);
4756   }
4757   return n;
4758 }
4759 
4760 
4761 
4762 int
4763 namecmp(const char *s, const char *t)
4764 {
4765   return strncmp(s, t, DIRSIZ);
4766 }
4767 
4768 
4769 
4770 struct inode*
4771 dirlookup(struct inode *dp, char *name, uint *poff)
4772 {
4773   uint off, inum;
4774   struct dirent de;
4775 
4776   if(dp->type != T_DIR)
4777     panic("dirlookup not DIR");
4778 
4779   for(off = 0; off < dp->size; off += sizeof(de)){
4780     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
4781       panic("dirlink read");
4782     if(de.inum == 0)
4783       continue;
4784     if(namecmp(name, de.name) == 0){
4785       
4786       if(poff)
4787         *poff = off;
4788       inum = de.inum;
4789       return iget(dp->dev, inum);
4790     }
4791   }
4792 
4793   return 0;
4794 }
4795 
4796 
4797 
4798 
4799 
4800 
4801 int
4802 dirlink(struct inode *dp, char *name, uint inum)
4803 {
4804   int off;
4805   struct dirent de;
4806   struct inode *ip;
4807 
4808   
4809   if((ip = dirlookup(dp, name, 0)) != 0){
4810     iput(ip);
4811     return -1;
4812   }
4813 
4814   
4815   for(off = 0; off < dp->size; off += sizeof(de)){
4816     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
4817       panic("dirlink read");
4818     if(de.inum == 0)
4819       break;
4820   }
4821 
4822   strncpy(de.name, name, DIRSIZ);
4823   de.inum = inum;
4824   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
4825     panic("dirlink");
4826 
4827   return 0;
4828 }
4829 
4830 
4831 
4832 
4833 
4834 
4835 
4836 
4837 
4838 
4839 
4840 
4841 
4842 
4843 
4844 static char*
4845 skipelem(char *path, char *name)
4846 {
4847   char *s;
4848   int len;
4849 
4850   while(*path == '/')
4851     path++;
4852   if(*path == 0)
4853     return 0;
4854   s = path;
4855   while(*path != '/' && *path != 0)
4856     path++;
4857   len = path - s;
4858   if(len >= DIRSIZ)
4859     memmove(name, s, DIRSIZ);
4860   else {
4861     memmove(name, s, len);
4862     name[len] = 0;
4863   }
4864   while(*path == '/')
4865     path++;
4866   return path;
4867 }
4868 
4869 
4870 
4871 
4872 
4873 static struct inode*
4874 namex(char *path, int nameiparent, char *name)
4875 {
4876   struct inode *ip, *next;
4877 
4878   if(*path == '/')
4879     ip = iget(ROOTDEV, ROOTINO);
4880   else
4881     ip = idup(proc->cwd);
4882 
4883   while((path = skipelem(path, name)) != 0){
4884     ilock(ip);
4885     if(ip->type != T_DIR){
4886       iunlockput(ip);
4887       return 0;
4888     }
4889     if(nameiparent && *path == '\0'){
4890       
4891       iunlock(ip);
4892       return ip;
4893     }
4894     if((next = dirlookup(ip, name, 0)) == 0){
4895       iunlockput(ip);
4896       return 0;
4897     }
4898     iunlockput(ip);
4899     ip = next;
4900   }
4901   if(nameiparent){
4902     iput(ip);
4903     return 0;
4904   }
4905   return ip;
4906 }
4907 
4908 struct inode*
4909 namei(char *path)
4910 {
4911   char name[DIRSIZ];
4912   return namex(path, 0, name);
4913 }
4914 
4915 struct inode*
4916 nameiparent(char *path, char *name)
4917 {
4918   return namex(path, 1, name);
4919 }
4920 
4921 
4922 
4923 
4924 
4925 
4926 
4927 
4928 
4929 
4930 
4931 
4932 
4933 
4934 
4935 
4936 
4937 
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 
4953 
4954 #include "types.h"
4955 #include "defs.h"
4956 #include "param.h"
4957 #include "fs.h"
4958 #include "file.h"
4959 #include "spinlock.h"
4960 
4961 struct devsw devsw[NDEV];
4962 struct {
4963   struct spinlock lock;
4964   struct file file[NFILE];
4965 } ftable;
4966 
4967 void
4968 fileinit(void)
4969 {
4970   initlock(&ftable.lock, "ftable");
4971 }
4972 
4973 
4974 struct file*
4975 filealloc(void)
4976 {
4977   struct file *f;
4978 
4979   acquire(&ftable.lock);
4980   for(f = ftable.file; f < ftable.file + NFILE; f++){
4981     if(f->ref == 0){
4982       f->ref = 1;
4983       release(&ftable.lock);
4984       return f;
4985     }
4986   }
4987   release(&ftable.lock);
4988   return 0;
4989 }
4990 
4991 
4992 
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 struct file*
5002 filedup(struct file *f)
5003 {
5004   acquire(&ftable.lock);
5005   if(f->ref < 1)
5006     panic("filedup");
5007   f->ref++;
5008   release(&ftable.lock);
5009   return f;
5010 }
5011 
5012 
5013 void
5014 fileclose(struct file *f)
5015 {
5016   struct file ff;
5017 
5018   acquire(&ftable.lock);
5019   if(f->ref < 1)
5020     panic("fileclose");
5021   if(--f->ref > 0){
5022     release(&ftable.lock);
5023     return;
5024   }
5025   ff = *f;
5026   f->ref = 0;
5027   f->type = FD_NONE;
5028   release(&ftable.lock);
5029 
5030   if(ff.type == FD_PIPE)
5031     pipeclose(ff.pipe, ff.writable);
5032   else if(ff.type == FD_INODE){
5033     begin_op();
5034     iput(ff.ip);
5035     end_op();
5036   }
5037 }
5038 
5039 
5040 
5041 
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 int
5052 filestat(struct file *f, struct stat *st)
5053 {
5054   if(f->type == FD_INODE){
5055     ilock(f->ip);
5056     stati(f->ip, st);
5057     iunlock(f->ip);
5058     return 0;
5059   }
5060   return -1;
5061 }
5062 
5063 
5064 int
5065 fileread(struct file *f, char *addr, int n)
5066 {
5067   int r;
5068 
5069   if(f->readable == 0)
5070     return -1;
5071   if(f->type == FD_PIPE)
5072     return piperead(f->pipe, addr, n);
5073   if(f->type == FD_INODE){
5074     ilock(f->ip);
5075     if((r = readi(f->ip, addr, f->off, n)) > 0)
5076       f->off += r;
5077     iunlock(f->ip);
5078     return r;
5079   }
5080   panic("fileread");
5081 }
5082 
5083 
5084 int
5085 filewrite(struct file *f, char *addr, int n)
5086 {
5087   int r;
5088 
5089   if(f->writable == 0)
5090     return -1;
5091   if(f->type == FD_PIPE)
5092     return pipewrite(f->pipe, addr, n);
5093   if(f->type == FD_INODE){
5094     
5095     
5096     
5097     
5098     
5099     
5100     int max = ((LOGSIZE-1-1-2) / 2) * 512;
5101     int i = 0;
5102     while(i < n){
5103       int n1 = n - i;
5104       if(n1 > max)
5105         n1 = max;
5106 
5107       begin_op();
5108       ilock(f->ip);
5109       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
5110         f->off += r;
5111       iunlock(f->ip);
5112       end_op();
5113 
5114       if(r < 0)
5115         break;
5116       if(r != n1)
5117         panic("short filewrite");
5118       i += r;
5119     }
5120     return i == n ? n : -1;
5121   }
5122   panic("filewrite");
5123 }
5124 
5125 
5126 
5127 
5128 
5129 
5130 
5131 
5132 
5133 
5134 
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 
5153 
5154 
5155 
5156 #include "types.h"
5157 #include "defs.h"
5158 #include "param.h"
5159 #include "stat.h"
5160 #include "mmu.h"
5161 #include "proc.h"
5162 #include "fs.h"
5163 #include "file.h"
5164 #include "fcntl.h"
5165 
5166 
5167 
5168 static int
5169 argfd(int n, int *pfd, struct file **pf)
5170 {
5171   int fd;
5172   struct file *f;
5173 
5174   if(argint(n, &fd) < 0)
5175     return -1;
5176   if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
5177     return -1;
5178   if(pfd)
5179     *pfd = fd;
5180   if(pf)
5181     *pf = f;
5182   return 0;
5183 }
5184 
5185 
5186 
5187 static int
5188 fdalloc(struct file *f)
5189 {
5190   int fd;
5191 
5192   for(fd = 0; fd < NOFILE; fd++){
5193     if(proc->ofile[fd] == 0){
5194       proc->ofile[fd] = f;
5195       return fd;
5196     }
5197   }
5198   return -1;
5199 }
5200 int
5201 sys_dup(void)
5202 {
5203   struct file *f;
5204   int fd;
5205 
5206   if(argfd(0, 0, &f) < 0)
5207     return -1;
5208   if((fd=fdalloc(f)) < 0)
5209     return -1;
5210   filedup(f);
5211   return fd;
5212 }
5213 
5214 int
5215 sys_read(void)
5216 {
5217   struct file *f;
5218   int n;
5219   char *p;
5220 
5221   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5222     return -1;
5223   return fileread(f, p, n);
5224 }
5225 
5226 int
5227 sys_write(void)
5228 {
5229   struct file *f;
5230   int n;
5231   char *p;
5232 
5233   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5234     return -1;
5235   return filewrite(f, p, n);
5236 }
5237 
5238 int
5239 sys_close(void)
5240 {
5241   int fd;
5242   struct file *f;
5243 
5244   if(argfd(0, &fd, &f) < 0)
5245     return -1;
5246   proc->ofile[fd] = 0;
5247   fileclose(f);
5248   return 0;
5249 }
5250 int
5251 sys_fstat(void)
5252 {
5253   struct file *f;
5254   struct stat *st;
5255 
5256   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
5257     return -1;
5258   return filestat(f, st);
5259 }
5260 
5261 
5262 int
5263 sys_link(void)
5264 {
5265   char name[DIRSIZ], *new, *old;
5266   struct inode *dp, *ip;
5267 
5268   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
5269     return -1;
5270 
5271   begin_op();
5272   if((ip = namei(old)) == 0){
5273     end_op();
5274     return -1;
5275   }
5276 
5277   ilock(ip);
5278   if(ip->type == T_DIR){
5279     iunlockput(ip);
5280     end_op();
5281     return -1;
5282   }
5283 
5284   ip->nlink++;
5285   iupdate(ip);
5286   iunlock(ip);
5287 
5288   if((dp = nameiparent(new, name)) == 0)
5289     goto bad;
5290   ilock(dp);
5291   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
5292     iunlockput(dp);
5293     goto bad;
5294   }
5295   iunlockput(dp);
5296   iput(ip);
5297 
5298   end_op();
5299 
5300   return 0;
5301 
5302 bad:
5303   ilock(ip);
5304   ip->nlink--;
5305   iupdate(ip);
5306   iunlockput(ip);
5307   end_op();
5308   return -1;
5309 }
5310 
5311 
5312 static int
5313 isdirempty(struct inode *dp)
5314 {
5315   int off;
5316   struct dirent de;
5317 
5318   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
5319     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5320       panic("isdirempty: readi");
5321     if(de.inum != 0)
5322       return 0;
5323   }
5324   return 1;
5325 }
5326 
5327 int
5328 sys_unlink(void)
5329 {
5330   struct inode *ip, *dp;
5331   struct dirent de;
5332   char name[DIRSIZ], *path;
5333   uint off;
5334 
5335   if(argstr(0, &path) < 0)
5336     return -1;
5337 
5338   begin_op();
5339   if((dp = nameiparent(path, name)) == 0){
5340     end_op();
5341     return -1;
5342   }
5343 
5344   ilock(dp);
5345 
5346   
5347   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
5348     goto bad;
5349 
5350   if((ip = dirlookup(dp, name, &off)) == 0)
5351     goto bad;
5352   ilock(ip);
5353 
5354   if(ip->nlink < 1)
5355     panic("unlink: nlink < 1");
5356   if(ip->type == T_DIR && !isdirempty(ip)){
5357     iunlockput(ip);
5358     goto bad;
5359   }
5360 
5361   memset(&de, 0, sizeof(de));
5362   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5363     panic("unlink: writei");
5364   if(ip->type == T_DIR){
5365     dp->nlink--;
5366     iupdate(dp);
5367   }
5368   iunlockput(dp);
5369 
5370   ip->nlink--;
5371   iupdate(ip);
5372   iunlockput(ip);
5373 
5374   end_op();
5375 
5376   return 0;
5377 
5378 bad:
5379   iunlockput(dp);
5380   end_op();
5381   return -1;
5382 }
5383 
5384 static struct inode*
5385 create(char *path, short type, short major, short minor)
5386 {
5387   uint off;
5388   struct inode *ip, *dp;
5389   char name[DIRSIZ];
5390 
5391   if((dp = nameiparent(path, name)) == 0)
5392     return 0;
5393   ilock(dp);
5394 
5395   if((ip = dirlookup(dp, name, &off)) != 0){
5396     iunlockput(dp);
5397     ilock(ip);
5398     if(type == T_FILE && ip->type == T_FILE)
5399       return ip;
5400     iunlockput(ip);
5401     return 0;
5402   }
5403 
5404   if((ip = ialloc(dp->dev, type)) == 0)
5405     panic("create: ialloc");
5406 
5407   ilock(ip);
5408   ip->major = major;
5409   ip->minor = minor;
5410   ip->nlink = 1;
5411   iupdate(ip);
5412 
5413   if(type == T_DIR){  
5414     dp->nlink++;  
5415     iupdate(dp);
5416     
5417     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
5418       panic("create dots");
5419   }
5420 
5421   if(dirlink(dp, name, ip->inum) < 0)
5422     panic("create: dirlink");
5423 
5424   iunlockput(dp);
5425 
5426   return ip;
5427 }
5428 
5429 int
5430 sys_open(void)
5431 {
5432   char *path;
5433   int fd, omode;
5434   struct file *f;
5435   struct inode *ip;
5436 
5437   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
5438     return -1;
5439 
5440   begin_op();
5441 
5442   if(omode & O_CREATE){
5443     ip = create(path, T_FILE, 0, 0);
5444     if(ip == 0){
5445       end_op();
5446       return -1;
5447     }
5448   } else {
5449     if((ip = namei(path)) == 0){
5450       end_op();
5451       return -1;
5452     }
5453     ilock(ip);
5454     if(ip->type == T_DIR && omode != O_RDONLY){
5455       iunlockput(ip);
5456       end_op();
5457       return -1;
5458     }
5459   }
5460 
5461   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
5462     if(f)
5463       fileclose(f);
5464     iunlockput(ip);
5465     end_op();
5466     return -1;
5467   }
5468   iunlock(ip);
5469   end_op();
5470 
5471   f->type = FD_INODE;
5472   f->ip = ip;
5473   f->off = 0;
5474   f->readable = !(omode & O_WRONLY);
5475   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
5476   return fd;
5477 }
5478 
5479 int
5480 sys_mkdir(void)
5481 {
5482   char *path;
5483   struct inode *ip;
5484 
5485   begin_op();
5486   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
5487     end_op();
5488     return -1;
5489   }
5490   iunlockput(ip);
5491   end_op();
5492   return 0;
5493 }
5494 
5495 
5496 
5497 
5498 
5499 
5500 int
5501 sys_mknod(void)
5502 {
5503   struct inode *ip;
5504   char *path;
5505   int len;
5506   int major, minor;
5507 
5508   begin_op();
5509   if((len=argstr(0, &path)) < 0 ||
5510      argint(1, &major) < 0 ||
5511      argint(2, &minor) < 0 ||
5512      (ip = create(path, T_DEV, major, minor)) == 0){
5513     end_op();
5514     return -1;
5515   }
5516   iunlockput(ip);
5517   end_op();
5518   return 0;
5519 }
5520 
5521 int
5522 sys_chdir(void)
5523 {
5524   char *path;
5525   struct inode *ip;
5526 
5527   begin_op();
5528   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
5529     end_op();
5530     return -1;
5531   }
5532   ilock(ip);
5533   if(ip->type != T_DIR){
5534     iunlockput(ip);
5535     end_op();
5536     return -1;
5537   }
5538   iunlock(ip);
5539   iput(proc->cwd);
5540   end_op();
5541   proc->cwd = ip;
5542   return 0;
5543 }
5544 
5545 
5546 
5547 
5548 
5549 
5550 int
5551 sys_exec(void)
5552 {
5553   char *path, *argv[MAXARG];
5554   int i;
5555   uint uargv, uarg;
5556 
5557   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
5558     return -1;
5559   }
5560   memset(argv, 0, sizeof(argv));
5561   for(i=0;; i++){
5562     if(i >= NELEM(argv))
5563       return -1;
5564     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
5565       return -1;
5566     if(uarg == 0){
5567       argv[i] = 0;
5568       break;
5569     }
5570     if(fetchstr(uarg, &argv[i]) < 0)
5571       return -1;
5572   }
5573   return exec(path, argv);
5574 }
5575 
5576 int
5577 sys_pipe(void)
5578 {
5579   int *fd;
5580   struct file *rf, *wf;
5581   int fd0, fd1;
5582 
5583   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
5584     return -1;
5585   if(pipealloc(&rf, &wf) < 0)
5586     return -1;
5587   fd0 = -1;
5588   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
5589     if(fd0 >= 0)
5590       proc->ofile[fd0] = 0;
5591     fileclose(rf);
5592     fileclose(wf);
5593     return -1;
5594   }
5595   fd[0] = fd0;
5596   fd[1] = fd1;
5597   return 0;
5598 }
5599 
5600 #include "types.h"
5601 #include "param.h"
5602 #include "memlayout.h"
5603 #include "mmu.h"
5604 #include "proc.h"
5605 #include "defs.h"
5606 #include "x86.h"
5607 #include "elf.h"
5608 
5609 int
5610 exec(char *path, char **argv)
5611 {
5612   char *s, *last;
5613   int i, off;
5614   uint argc, sz, sp, ustack[3+MAXARG+1];
5615   struct elfhdr elf;
5616   struct inode *ip;
5617   struct proghdr ph;
5618   pde_t *pgdir, *oldpgdir;
5619 
5620   begin_op();
5621   if((ip = namei(path)) == 0){
5622     end_op();
5623     return -1;
5624   }
5625   ilock(ip);
5626   pgdir = 0;
5627 
5628   
5629   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
5630     goto bad;
5631   if(elf.magic != ELF_MAGIC)
5632     goto bad;
5633 
5634   if((pgdir = setupkvm()) == 0)
5635     goto bad;
5636 
5637   
5638   sz = 0;
5639   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
5640     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
5641       goto bad;
5642     if(ph.type != ELF_PROG_LOAD)
5643       continue;
5644     if(ph.memsz < ph.filesz)
5645       goto bad;
5646     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
5647       goto bad;
5648     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
5649       goto bad;
5650   }
5651   iunlockput(ip);
5652   end_op();
5653   ip = 0;
5654 
5655   
5656   
5657   sz = PGROUNDUP(sz);
5658   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
5659     goto bad;
5660   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
5661   sp = sz;
5662 
5663   
5664   for(argc = 0; argv[argc]; argc++) {
5665     if(argc >= MAXARG)
5666       goto bad;
5667     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
5668     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
5669       goto bad;
5670     ustack[3+argc] = sp;
5671   }
5672   ustack[3+argc] = 0;
5673 
5674   ustack[0] = 0xffffffff;  
5675   ustack[1] = argc;
5676   ustack[2] = sp - (argc+1)*4;  
5677 
5678   sp -= (3+argc+1) * 4;
5679   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
5680     goto bad;
5681 
5682   
5683   for(last=s=path; *s; s++)
5684     if(*s == '/')
5685       last = s+1;
5686   safestrcpy(proc->name, last, sizeof(proc->name));
5687 
5688   
5689   oldpgdir = proc->pgdir;
5690   proc->pgdir = pgdir;
5691   proc->sz = sz;
5692   proc->tf->eip = elf.entry;  
5693   proc->tf->esp = sp;
5694   switchuvm(proc);
5695   freevm(oldpgdir);
5696   return 0;
5697 
5698 
5699 
5700  bad:
5701   if(pgdir)
5702     freevm(pgdir);
5703   if(ip){
5704     iunlockput(ip);
5705     end_op();
5706   }
5707   return -1;
5708 }
5709 
5710 
5711 
5712 
5713 
5714 
5715 
5716 
5717 
5718 
5719 
5720 
5721 
5722 
5723 
5724 
5725 
5726 
5727 
5728 
5729 
5730 
5731 
5732 
5733 
5734 
5735 
5736 
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 #include "types.h"
5751 #include "defs.h"
5752 #include "param.h"
5753 #include "mmu.h"
5754 #include "proc.h"
5755 #include "fs.h"
5756 #include "file.h"
5757 #include "spinlock.h"
5758 
5759 #define PIPESIZE 512
5760 
5761 struct pipe {
5762   struct spinlock lock;
5763   char data[PIPESIZE];
5764   uint nread;     
5765   uint nwrite;    
5766   int readopen;   
5767   int writeopen;  
5768 };
5769 
5770 int
5771 pipealloc(struct file **f0, struct file **f1)
5772 {
5773   struct pipe *p;
5774 
5775   p = 0;
5776   *f0 = *f1 = 0;
5777   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
5778     goto bad;
5779   if((p = (struct pipe*)kalloc()) == 0)
5780     goto bad;
5781   p->readopen = 1;
5782   p->writeopen = 1;
5783   p->nwrite = 0;
5784   p->nread = 0;
5785   initlock(&p->lock, "pipe");
5786   (*f0)->type = FD_PIPE;
5787   (*f0)->readable = 1;
5788   (*f0)->writable = 0;
5789   (*f0)->pipe = p;
5790   (*f1)->type = FD_PIPE;
5791   (*f1)->readable = 0;
5792   (*f1)->writable = 1;
5793   (*f1)->pipe = p;
5794   return 0;
5795 
5796 
5797 
5798 
5799 
5800  bad:
5801   if(p)
5802     kfree((char*)p);
5803   if(*f0)
5804     fileclose(*f0);
5805   if(*f1)
5806     fileclose(*f1);
5807   return -1;
5808 }
5809 
5810 void
5811 pipeclose(struct pipe *p, int writable)
5812 {
5813   acquire(&p->lock);
5814   if(writable){
5815     p->writeopen = 0;
5816     wakeup(&p->nread);
5817   } else {
5818     p->readopen = 0;
5819     wakeup(&p->nwrite);
5820   }
5821   if(p->readopen == 0 && p->writeopen == 0){
5822     release(&p->lock);
5823     kfree((char*)p);
5824   } else
5825     release(&p->lock);
5826 }
5827 
5828 int
5829 pipewrite(struct pipe *p, char *addr, int n)
5830 {
5831   int i;
5832 
5833   acquire(&p->lock);
5834   for(i = 0; i < n; i++){
5835     while(p->nwrite == p->nread + PIPESIZE){  
5836       if(p->readopen == 0 || proc->killed){
5837         release(&p->lock);
5838         return -1;
5839       }
5840       wakeup(&p->nread);
5841       sleep(&p->nwrite, &p->lock);  
5842     }
5843     p->data[p->nwrite++ % PIPESIZE] = addr[i];
5844   }
5845   wakeup(&p->nread);  
5846   release(&p->lock);
5847   return n;
5848 }
5849 
5850 int
5851 piperead(struct pipe *p, char *addr, int n)
5852 {
5853   int i;
5854 
5855   acquire(&p->lock);
5856   while(p->nread == p->nwrite && p->writeopen){  
5857     if(proc->killed){
5858       release(&p->lock);
5859       return -1;
5860     }
5861     sleep(&p->nread, &p->lock); 
5862   }
5863   for(i = 0; i < n; i++){  
5864     if(p->nread == p->nwrite)
5865       break;
5866     addr[i] = p->data[p->nread++ % PIPESIZE];
5867   }
5868   wakeup(&p->nwrite);  
5869   release(&p->lock);
5870   return i;
5871 }
5872 
5873 
5874 
5875 
5876 
5877 
5878 
5879 
5880 
5881 
5882 
5883 
5884 
5885 
5886 
5887 
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 #include "types.h"
5901 #include "x86.h"
5902 
5903 void*
5904 memset(void *dst, int c, uint n)
5905 {
5906   if ((int)dst%4 == 0 && n%4 == 0){
5907     c &= 0xFF;
5908     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
5909   } else
5910     stosb(dst, c, n);
5911   return dst;
5912 }
5913 
5914 int
5915 memcmp(const void *v1, const void *v2, uint n)
5916 {
5917   const uchar *s1, *s2;
5918 
5919   s1 = v1;
5920   s2 = v2;
5921   while(n-- > 0){
5922     if(*s1 != *s2)
5923       return *s1 - *s2;
5924     s1++, s2++;
5925   }
5926 
5927   return 0;
5928 }
5929 
5930 void*
5931 memmove(void *dst, const void *src, uint n)
5932 {
5933   const char *s;
5934   char *d;
5935 
5936   s = src;
5937   d = dst;
5938   if(s < d && s + n > d){
5939     s += n;
5940     d += n;
5941     while(n-- > 0)
5942       *--d = *--s;
5943   } else
5944     while(n-- > 0)
5945       *d++ = *s++;
5946 
5947   return dst;
5948 }
5949 
5950 
5951 void*
5952 memcpy(void *dst, const void *src, uint n)
5953 {
5954   return memmove(dst, src, n);
5955 }
5956 
5957 int
5958 strncmp(const char *p, const char *q, uint n)
5959 {
5960   while(n > 0 && *p && *p == *q)
5961     n--, p++, q++;
5962   if(n == 0)
5963     return 0;
5964   return (uchar)*p - (uchar)*q;
5965 }
5966 
5967 char*
5968 strncpy(char *s, const char *t, int n)
5969 {
5970   char *os;
5971 
5972   os = s;
5973   while(n-- > 0 && (*s++ = *t++) != 0)
5974     ;
5975   while(n-- > 0)
5976     *s++ = 0;
5977   return os;
5978 }
5979 
5980 
5981 char*
5982 safestrcpy(char *s, const char *t, int n)
5983 {
5984   char *os;
5985 
5986   os = s;
5987   if(n <= 0)
5988     return os;
5989   while(--n > 0 && (*s++ = *t++) != 0)
5990     ;
5991   *s = 0;
5992   return os;
5993 }
5994 
5995 
5996 
5997 
5998 
5999 
6000 int
6001 strlen(const char *s)
6002 {
6003   int n;
6004 
6005   for(n = 0; s[n]; n++)
6006     ;
6007   return n;
6008 }
6009 
6010 
6011 
6012 
6013 
6014 
6015 
6016 
6017 
6018 
6019 
6020 
6021 
6022 
6023 
6024 
6025 
6026 
6027 
6028 
6029 
6030 
6031 
6032 
6033 
6034 
6035 
6036 
6037 
6038 
6039 
6040 
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 
6051 
6052 struct mp {             
6053   uchar signature[4];           
6054   void *physaddr;               
6055   uchar length;                 
6056   uchar specrev;                
6057   uchar checksum;               
6058   uchar type;                   
6059   uchar imcrp;
6060   uchar reserved[3];
6061 };
6062 
6063 struct mpconf {         
6064   uchar signature[4];           
6065   ushort length;                
6066   uchar version;                
6067   uchar checksum;               
6068   uchar product[20];            
6069   uint *oemtable;               
6070   ushort oemlength;             
6071   ushort entry;                 
6072   uint *lapicaddr;              
6073   ushort xlength;               
6074   uchar xchecksum;              
6075   uchar reserved;
6076 };
6077 
6078 struct mpproc {         
6079   uchar type;                   
6080   uchar apicid;                 
6081   uchar version;                
6082   uchar flags;                  
6083     #define MPBOOT 0x02           
6084   uchar signature[4];           
6085   uint feature;                 
6086   uchar reserved[8];
6087 };
6088 
6089 struct mpioapic {       
6090   uchar type;                   
6091   uchar apicno;                 
6092   uchar version;                
6093   uchar flags;                  
6094   uint *addr;                  
6095 };
6096 
6097 
6098 
6099 
6100 
6101 #define MPPROC    0x00  
6102 #define MPBUS     0x01  
6103 #define MPIOAPIC  0x02  
6104 #define MPIOINTR  0x03  
6105 #define MPLINTR   0x04  
6106 
6107 
6108 
6109 
6110 
6111 
6112 
6113 
6114 
6115 
6116 
6117 
6118 
6119 
6120 
6121 
6122 
6123 
6124 
6125 
6126 
6127 
6128 
6129 
6130 
6131 
6132 
6133 
6134 
6135 
6136 
6137 
6138 
6139 
6140 
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 
6152 
6153 
6154 #include "types.h"
6155 #include "defs.h"
6156 #include "param.h"
6157 #include "memlayout.h"
6158 #include "mp.h"
6159 #include "x86.h"
6160 #include "mmu.h"
6161 #include "proc.h"
6162 
6163 struct cpu cpus[NCPU];
6164 static struct cpu *bcpu;
6165 int ismp;
6166 int ncpu;
6167 uchar ioapicid;
6168 
6169 int
6170 mpbcpu(void)
6171 {
6172   return bcpu-cpus;
6173 }
6174 
6175 static uchar
6176 sum(uchar *addr, int len)
6177 {
6178   int i, sum;
6179 
6180   sum = 0;
6181   for(i=0; i<len; i++)
6182     sum += addr[i];
6183   return sum;
6184 }
6185 
6186 
6187 static struct mp*
6188 mpsearch1(uint a, int len)
6189 {
6190   uchar *e, *p, *addr;
6191 
6192   addr = p2v(a);
6193   e = addr+len;
6194   for(p = addr; p < e; p += sizeof(struct mp))
6195     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
6196       return (struct mp*)p;
6197   return 0;
6198 }
6199 
6200 
6201 
6202 
6203 
6204 
6205 static struct mp*
6206 mpsearch(void)
6207 {
6208   uchar *bda;
6209   uint p;
6210   struct mp *mp;
6211 
6212   bda = (uchar *) P2V(0x400);
6213   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
6214     if((mp = mpsearch1(p, 1024)))
6215       return mp;
6216   } else {
6217     p = ((bda[0x14]<<8)|bda[0x13])*1024;
6218     if((mp = mpsearch1(p-1024, 1024)))
6219       return mp;
6220   }
6221   return mpsearch1(0xF0000, 0x10000);
6222 }
6223 
6224 
6225 
6226 
6227 
6228 
6229 static struct mpconf*
6230 mpconfig(struct mp **pmp)
6231 {
6232   struct mpconf *conf;
6233   struct mp *mp;
6234 
6235   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
6236     return 0;
6237   conf = (struct mpconf*) p2v((uint) mp->physaddr);
6238   if(memcmp(conf, "PCMP", 4) != 0)
6239     return 0;
6240   if(conf->version != 1 && conf->version != 4)
6241     return 0;
6242   if(sum((uchar*)conf, conf->length) != 0)
6243     return 0;
6244   *pmp = mp;
6245   return conf;
6246 }
6247 
6248 
6249 
6250 void
6251 mpinit(void)
6252 {
6253   uchar *p, *e;
6254   struct mp *mp;
6255   struct mpconf *conf;
6256   struct mpproc *proc;
6257   struct mpioapic *ioapic;
6258 
6259   bcpu = &cpus[0];
6260   if((conf = mpconfig(&mp)) == 0)
6261     return;
6262   ismp = 1;
6263   lapic = (uint*)conf->lapicaddr;
6264   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
6265     switch(*p){
6266     case MPPROC:
6267       proc = (struct mpproc*)p;
6268       if(ncpu != proc->apicid){
6269         cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
6270         ismp = 0;
6271       }
6272       if(proc->flags & MPBOOT)
6273         bcpu = &cpus[ncpu];
6274       cpus[ncpu].id = ncpu;
6275       ncpu++;
6276       p += sizeof(struct mpproc);
6277       continue;
6278     case MPIOAPIC:
6279       ioapic = (struct mpioapic*)p;
6280       ioapicid = ioapic->apicno;
6281       p += sizeof(struct mpioapic);
6282       continue;
6283     case MPBUS:
6284     case MPIOINTR:
6285     case MPLINTR:
6286       p += 8;
6287       continue;
6288     default:
6289       cprintf("mpinit: unknown config type %x\n", *p);
6290       ismp = 0;
6291     }
6292   }
6293   if(!ismp){
6294     
6295     ncpu = 1;
6296     lapic = 0;
6297     ioapicid = 0;
6298     return;
6299   }
6300   if(mp->imcrp){
6301     
6302     
6303     outb(0x22, 0x70);   
6304     outb(0x23, inb(0x23) | 1);  
6305   }
6306 }
6307 
6308 
6309 
6310 
6311 
6312 
6313 
6314 
6315 
6316 
6317 
6318 
6319 
6320 
6321 
6322 
6323 
6324 
6325 
6326 
6327 
6328 
6329 
6330 
6331 
6332 
6333 
6334 
6335 
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 
6352 
6353 #include "types.h"
6354 #include "defs.h"
6355 #include "date.h"
6356 #include "memlayout.h"
6357 #include "traps.h"
6358 #include "mmu.h"
6359 #include "x86.h"
6360 
6361 
6362 #define ID      (0x0020/4)   
6363 #define VER     (0x0030/4)   
6364 #define TPR     (0x0080/4)   
6365 #define EOI     (0x00B0/4)   
6366 #define SVR     (0x00F0/4)   
6367   #define ENABLE     0x00000100   
6368 #define ESR     (0x0280/4)   
6369 #define ICRLO   (0x0300/4)   
6370   #define INIT       0x00000500   
6371   #define STARTUP    0x00000600   
6372   #define DELIVS     0x00001000   
6373   #define ASSERT     0x00004000   
6374   #define DEASSERT   0x00000000
6375   #define LEVEL      0x00008000   
6376   #define BCAST      0x00080000   
6377   #define BUSY       0x00001000
6378   #define FIXED      0x00000000
6379 #define ICRHI   (0x0310/4)   
6380 #define TIMER   (0x0320/4)   
6381   #define X1         0x0000000B   
6382   #define PERIODIC   0x00020000   
6383 #define PCINT   (0x0340/4)   
6384 #define LINT0   (0x0350/4)   
6385 #define LINT1   (0x0360/4)   
6386 #define ERROR   (0x0370/4)   
6387   #define MASKED     0x00010000   
6388 #define TICR    (0x0380/4)   
6389 #define TCCR    (0x0390/4)   
6390 #define TDCR    (0x03E0/4)   
6391 
6392 volatile uint *lapic;  
6393 
6394 static void
6395 lapicw(int index, int value)
6396 {
6397   lapic[index] = value;
6398   lapic[ID];  
6399 }
6400 void
6401 lapicinit(void)
6402 {
6403   if(!lapic)
6404     return;
6405 
6406   
6407   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
6408 
6409   
6410   
6411   
6412   
6413   lapicw(TDCR, X1);
6414   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
6415   lapicw(TICR, 10000000);
6416 
6417   
6418   lapicw(LINT0, MASKED);
6419   lapicw(LINT1, MASKED);
6420 
6421   
6422   
6423   if(((lapic[VER]>>16) & 0xFF) >= 4)
6424     lapicw(PCINT, MASKED);
6425 
6426   
6427   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
6428 
6429   
6430   lapicw(ESR, 0);
6431   lapicw(ESR, 0);
6432 
6433   
6434   lapicw(EOI, 0);
6435 
6436   
6437   lapicw(ICRHI, 0);
6438   lapicw(ICRLO, BCAST | INIT | LEVEL);
6439   while(lapic[ICRLO] & DELIVS)
6440     ;
6441 
6442   
6443   lapicw(TPR, 0);
6444 }
6445 
6446 
6447 
6448 
6449 
6450 int
6451 cpunum(void)
6452 {
6453   
6454   
6455   
6456   
6457   
6458   if(readeflags()&FL_IF){
6459     static int n;
6460     if(n++ == 0)
6461       cprintf("cpu called from %x with interrupts enabled\n",
6462         __builtin_return_address(0));
6463   }
6464 
6465   if(lapic)
6466     return lapic[ID]>>24;
6467   return 0;
6468 }
6469 
6470 
6471 void
6472 lapiceoi(void)
6473 {
6474   if(lapic)
6475     lapicw(EOI, 0);
6476 }
6477 
6478 
6479 
6480 void
6481 microdelay(int us)
6482 {
6483 }
6484 
6485 #define CMOS_PORT    0x70
6486 #define CMOS_RETURN  0x71
6487 
6488 
6489 
6490 void
6491 lapicstartap(uchar apicid, uint addr)
6492 {
6493   int i;
6494   ushort *wrv;
6495 
6496   
6497   
6498   
6499   outb(CMOS_PORT, 0xF);  
6500   outb(CMOS_PORT+1, 0x0A);
6501   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
6502   wrv[0] = 0;
6503   wrv[1] = addr >> 4;
6504 
6505   
6506   
6507   lapicw(ICRHI, apicid<<24);
6508   lapicw(ICRLO, INIT | LEVEL | ASSERT);
6509   microdelay(200);
6510   lapicw(ICRLO, INIT | LEVEL);
6511   microdelay(100);    
6512 
6513   
6514   
6515   
6516   
6517   
6518   for(i = 0; i < 2; i++){
6519     lapicw(ICRHI, apicid<<24);
6520     lapicw(ICRLO, STARTUP | (addr>>12));
6521     microdelay(200);
6522   }
6523 }
6524 
6525 #define CMOS_STATA   0x0a
6526 #define CMOS_STATB   0x0b
6527 #define CMOS_UIP    (1 << 7)        
6528 
6529 #define SECS    0x00
6530 #define MINS    0x02
6531 #define HOURS   0x04
6532 #define DAY     0x07
6533 #define MONTH   0x08
6534 #define YEAR    0x09
6535 
6536 static uint cmos_read(uint reg)
6537 {
6538   outb(CMOS_PORT,  reg);
6539   microdelay(200);
6540 
6541   return inb(CMOS_RETURN);
6542 }
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 static void fill_rtcdate(struct rtcdate *r)
6551 {
6552   r->second = cmos_read(SECS);
6553   r->minute = cmos_read(MINS);
6554   r->hour   = cmos_read(HOURS);
6555   r->day    = cmos_read(DAY);
6556   r->month  = cmos_read(MONTH);
6557   r->year   = cmos_read(YEAR);
6558 }
6559 
6560 
6561 void cmostime(struct rtcdate *r)
6562 {
6563   struct rtcdate t1, t2;
6564   int sb, bcd;
6565 
6566   sb = cmos_read(CMOS_STATB);
6567 
6568   bcd = (sb & (1 << 2)) == 0;
6569 
6570   
6571   for (;;) {
6572     fill_rtcdate(&t1);
6573     if (cmos_read(CMOS_STATA) & CMOS_UIP)
6574         continue;
6575     fill_rtcdate(&t2);
6576     if (memcmp(&t1, &t2, sizeof(t1)) == 0)
6577       break;
6578   }
6579 
6580   
6581   if (bcd) {
6582 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
6583     CONV(second);
6584     CONV(minute);
6585     CONV(hour  );
6586     CONV(day   );
6587     CONV(month );
6588     CONV(year  );
6589 #undef     CONV
6590   }
6591 
6592   *r = t1;
6593   r->year += 2000;
6594 }
6595 
6596 
6597 
6598 
6599 
6600 
6601 
6602 
6603 
6604 #include "types.h"
6605 #include "defs.h"
6606 #include "traps.h"
6607 
6608 #define IOAPIC  0xFEC00000   
6609 
6610 #define REG_ID     0x00  
6611 #define REG_VER    0x01  
6612 #define REG_TABLE  0x10  
6613 
6614 
6615 
6616 
6617 
6618 
6619 #define INT_DISABLED   0x00010000  
6620 #define INT_LEVEL      0x00008000  
6621 #define INT_ACTIVELOW  0x00002000  
6622 #define INT_LOGICAL    0x00000800  
6623 
6624 volatile struct ioapic *ioapic;
6625 
6626 
6627 struct ioapic {
6628   uint reg;
6629   uint pad[3];
6630   uint data;
6631 };
6632 
6633 static uint
6634 ioapicread(int reg)
6635 {
6636   ioapic->reg = reg;
6637   return ioapic->data;
6638 }
6639 
6640 static void
6641 ioapicwrite(int reg, uint data)
6642 {
6643   ioapic->reg = reg;
6644   ioapic->data = data;
6645 }
6646 
6647 
6648 
6649 
6650 void
6651 ioapicinit(void)
6652 {
6653   int i, id, maxintr;
6654 
6655   if(!ismp)
6656     return;
6657 
6658   ioapic = (volatile struct ioapic*)IOAPIC;
6659   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
6660   id = ioapicread(REG_ID) >> 24;
6661   if(id != ioapicid)
6662     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
6663 
6664   
6665   
6666   for(i = 0; i <= maxintr; i++){
6667     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
6668     ioapicwrite(REG_TABLE+2*i+1, 0);
6669   }
6670 }
6671 
6672 void
6673 ioapicenable(int irq, int cpunum)
6674 {
6675   if(!ismp)
6676     return;
6677 
6678   
6679   
6680   
6681   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
6682   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
6683 }
6684 
6685 
6686 
6687 
6688 
6689 
6690 
6691 
6692 
6693 
6694 
6695 
6696 
6697 
6698 
6699 
6700 
6701 
6702 #include "types.h"
6703 #include "x86.h"
6704 #include "traps.h"
6705 
6706 
6707 #define IO_PIC1         0x20    
6708 #define IO_PIC2         0xA0    
6709 
6710 #define IRQ_SLAVE       2       
6711 
6712 
6713 
6714 static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
6715 
6716 static void
6717 picsetmask(ushort mask)
6718 {
6719   irqmask = mask;
6720   outb(IO_PIC1+1, mask);
6721   outb(IO_PIC2+1, mask >> 8);
6722 }
6723 
6724 void
6725 picenable(int irq)
6726 {
6727   picsetmask(irqmask & ~(1<<irq));
6728 }
6729 
6730 
6731 void
6732 picinit(void)
6733 {
6734   
6735   outb(IO_PIC1+1, 0xFF);
6736   outb(IO_PIC2+1, 0xFF);
6737 
6738   
6739 
6740   
6741   
6742   
6743   
6744   outb(IO_PIC1, 0x11);
6745 
6746   
6747   outb(IO_PIC1+1, T_IRQ0);
6748 
6749 
6750   
6751   
6752   outb(IO_PIC1+1, 1<<IRQ_SLAVE);
6753 
6754   
6755   
6756   
6757   
6758   
6759   
6760   
6761   
6762   outb(IO_PIC1+1, 0x3);
6763 
6764   
6765   outb(IO_PIC2, 0x11);                  
6766   outb(IO_PIC2+1, T_IRQ0 + 8);      
6767   outb(IO_PIC2+1, IRQ_SLAVE);           
6768   
6769   
6770   outb(IO_PIC2+1, 0x3);                 
6771 
6772   
6773   
6774   
6775   
6776   outb(IO_PIC1, 0x68);             
6777   outb(IO_PIC1, 0x0a);             
6778 
6779   outb(IO_PIC2, 0x68);             
6780   outb(IO_PIC2, 0x0a);             
6781 
6782   if(irqmask != 0xFFFF)
6783     picsetmask(irqmask);
6784 }
6785 
6786 
6787 
6788 
6789 
6790 
6791 
6792 
6793 
6794 
6795 
6796 
6797 
6798 
6799 
6800 
6801 
6802 #define KBSTATP         0x64    
6803 #define KBS_DIB         0x01    
6804 #define KBDATAP         0x60    
6805 
6806 #define NO              0
6807 
6808 #define SHIFT           (1<<0)
6809 #define CTL             (1<<1)
6810 #define ALT             (1<<2)
6811 
6812 #define CAPSLOCK        (1<<3)
6813 #define NUMLOCK         (1<<4)
6814 #define SCROLLLOCK      (1<<5)
6815 
6816 #define E0ESC           (1<<6)
6817 
6818 
6819 #define KEY_HOME        0xE0
6820 #define KEY_END         0xE1
6821 #define KEY_UP          0xE2
6822 #define KEY_DN          0xE3
6823 #define KEY_LF          0xE4
6824 #define KEY_RT          0xE5
6825 #define KEY_PGUP        0xE6
6826 #define KEY_PGDN        0xE7
6827 #define KEY_INS         0xE8
6828 #define KEY_DEL         0xE9
6829 
6830 
6831 #define C(x) (x - '@')
6832 
6833 static uchar shiftcode[256] =
6834 {
6835   [0x1D] CTL,
6836   [0x2A] SHIFT,
6837   [0x36] SHIFT,
6838   [0x38] ALT,
6839   [0x9D] CTL,
6840   [0xB8] ALT
6841 };
6842 
6843 static uchar togglecode[256] =
6844 {
6845   [0x3A] CAPSLOCK,
6846   [0x45] NUMLOCK,
6847   [0x46] SCROLLLOCK
6848 };
6849 
6850 static uchar normalmap[256] =
6851 {
6852   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
6853   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
6854   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
6855   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
6856   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
6857   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
6858   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
6859   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
6860   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
6861   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
6862   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
6863   [0x9C] '\n',      
6864   [0xB5] '/',       
6865   [0xC8] KEY_UP,    [0xD0] KEY_DN,
6866   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
6867   [0xCB] KEY_LF,    [0xCD] KEY_RT,
6868   [0x97] KEY_HOME,  [0xCF] KEY_END,
6869   [0xD2] KEY_INS,   [0xD3] KEY_DEL
6870 };
6871 
6872 static uchar shiftmap[256] =
6873 {
6874   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
6875   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
6876   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
6877   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
6878   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
6879   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
6880   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
6881   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
6882   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
6883   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
6884   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
6885   [0x9C] '\n',      
6886   [0xB5] '/',       
6887   [0xC8] KEY_UP,    [0xD0] KEY_DN,
6888   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
6889   [0xCB] KEY_LF,    [0xCD] KEY_RT,
6890   [0x97] KEY_HOME,  [0xCF] KEY_END,
6891   [0xD2] KEY_INS,   [0xD3] KEY_DEL
6892 };
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 static uchar ctlmap[256] =
6901 {
6902   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
6903   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
6904   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
6905   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
6906   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
6907   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
6908   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
6909   [0x9C] '\r',      
6910   [0xB5] C('/'),    
6911   [0xC8] KEY_UP,    [0xD0] KEY_DN,
6912   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
6913   [0xCB] KEY_LF,    [0xCD] KEY_RT,
6914   [0x97] KEY_HOME,  [0xCF] KEY_END,
6915   [0xD2] KEY_INS,   [0xD3] KEY_DEL
6916 };
6917 
6918 
6919 
6920 
6921 
6922 
6923 
6924 
6925 
6926 
6927 
6928 
6929 
6930 
6931 
6932 
6933 
6934 
6935 
6936 
6937 
6938 
6939 
6940 
6941 
6942 
6943 
6944 
6945 
6946 
6947 
6948 
6949 
6950 #include "types.h"
6951 #include "x86.h"
6952 #include "defs.h"
6953 #include "kbd.h"
6954 
6955 int
6956 kbdgetc(void)
6957 {
6958   static uint shift;
6959   static uchar *charcode[4] = {
6960     normalmap, shiftmap, ctlmap, ctlmap
6961   };
6962   uint st, data, c;
6963 
6964   st = inb(KBSTATP);
6965   if((st & KBS_DIB) == 0)
6966     return -1;
6967   data = inb(KBDATAP);
6968 
6969   if(data == 0xE0){
6970     shift |= E0ESC;
6971     return 0;
6972   } else if(data & 0x80){
6973     
6974     data = (shift & E0ESC ? data : data & 0x7F);
6975     shift &= ~(shiftcode[data] | E0ESC);
6976     return 0;
6977   } else if(shift & E0ESC){
6978     
6979     data |= 0x80;
6980     shift &= ~E0ESC;
6981   }
6982 
6983   shift |= shiftcode[data];
6984   shift ^= togglecode[data];
6985   c = charcode[shift & (CTL | SHIFT)][data];
6986   if(shift & CAPSLOCK){
6987     if('a' <= c && c <= 'z')
6988       c += 'A' - 'a';
6989     else if('A' <= c && c <= 'Z')
6990       c += 'a' - 'A';
6991   }
6992   return c;
6993 }
6994 
6995 void
6996 kbdintr(void)
6997 {
6998   consoleintr(kbdgetc);
6999 }
7000 
7001 
7002 
7003 
7004 #include "types.h"
7005 #include "defs.h"
7006 #include "param.h"
7007 #include "traps.h"
7008 #include "spinlock.h"
7009 #include "fs.h"
7010 #include "file.h"
7011 #include "memlayout.h"
7012 #include "mmu.h"
7013 #include "proc.h"
7014 #include "x86.h"
7015 
7016 static void consputc(int);
7017 
7018 static int panicked = 0;
7019 
7020 static struct {
7021   struct spinlock lock;
7022   int locking;
7023 } cons;
7024 
7025 static void
7026 printint(int xx, int base, int sign)
7027 {
7028   static char digits[] = "0123456789abcdef";
7029   char buf[16];
7030   int i;
7031   uint x;
7032 
7033   if(sign && (sign = xx < 0))
7034     x = -xx;
7035   else
7036     x = xx;
7037 
7038   i = 0;
7039   do{
7040     buf[i++] = digits[x % base];
7041   }while((x /= base) != 0);
7042 
7043   if(sign)
7044     buf[i++] = '-';
7045 
7046   while(--i >= 0)
7047     consputc(buf[i]);
7048 }
7049 
7050 
7051 void
7052 cprintf(char *fmt, ...)
7053 {
7054   int i, c, locking;
7055   uint *argp;
7056   char *s;
7057 
7058   locking = cons.locking;
7059   if(locking)
7060     acquire(&cons.lock);
7061 
7062   if (fmt == 0)
7063     panic("null fmt");
7064 
7065   argp = (uint*)(void*)(&fmt + 1);
7066   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
7067     if(c != '%'){
7068       consputc(c);
7069       continue;
7070     }
7071     c = fmt[++i] & 0xff;
7072     if(c == 0)
7073       break;
7074     switch(c){
7075     case 'd':
7076       printint(*argp++, 10, 1);
7077       break;
7078     case 'x':
7079     case 'p':
7080       printint(*argp++, 16, 0);
7081       break;
7082     case 's':
7083       if((s = (char*)*argp++) == 0)
7084         s = "(null)";
7085       for(; *s; s++)
7086         consputc(*s);
7087       break;
7088     case '%':
7089       consputc('%');
7090       break;
7091     default:
7092       
7093       consputc('%');
7094       consputc(c);
7095       break;
7096     }
7097   }
7098 
7099 
7100   if(locking)
7101     release(&cons.lock);
7102 }
7103 
7104 void
7105 panic(char *s)
7106 {
7107   int i;
7108   uint pcs[10];
7109 
7110   cli();
7111   cons.locking = 0;
7112   cprintf("cpu%d: panic: ", cpu->id);
7113   cprintf(s);
7114   cprintf("\n");
7115   getcallerpcs(&s, pcs);
7116   for(i=0; i<10; i++)
7117     cprintf(" %p", pcs[i]);
7118   panicked = 1; 
7119   for(;;)
7120     ;
7121 }
7122 
7123 #define BACKSPACE 0x100
7124 #define CRTPORT 0x3d4
7125 static ushort *crt = (ushort*)P2V(0xb8000);  
7126 
7127 static void
7128 cgaputc(int c)
7129 {
7130   int pos;
7131 
7132   
7133   outb(CRTPORT, 14);
7134   pos = inb(CRTPORT+1) << 8;
7135   outb(CRTPORT, 15);
7136   pos |= inb(CRTPORT+1);
7137 
7138   if(c == '\n')
7139     pos += 80 - pos%80;
7140   else if(c == BACKSPACE){
7141     if(pos > 0) --pos;
7142   } else
7143     crt[pos++] = (c&0xff) | 0x0700;  
7144 
7145   if(pos < 0 || pos > 25*80)
7146     panic("pos under/overflow");
7147 
7148 
7149 
7150   if((pos/80) >= 24){  
7151     memmove(crt, crt+80, sizeof(crt[0])*23*80);
7152     pos -= 80;
7153     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
7154   }
7155 
7156   outb(CRTPORT, 14);
7157   outb(CRTPORT+1, pos>>8);
7158   outb(CRTPORT, 15);
7159   outb(CRTPORT+1, pos);
7160   crt[pos] = ' ' | 0x0700;
7161 }
7162 
7163 void
7164 consputc(int c)
7165 {
7166   if(panicked){
7167     cli();
7168     for(;;)
7169       ;
7170   }
7171 
7172   if(c == BACKSPACE){
7173     uartputc('\b'); uartputc(' '); uartputc('\b');
7174   } else
7175     uartputc(c);
7176   cgaputc(c);
7177 }
7178 
7179 #define INPUT_BUF 128
7180 struct {
7181   char buf[INPUT_BUF];
7182   uint r;  
7183   uint w;  
7184   uint e;  
7185 } input;
7186 
7187 #define C(x)  ((x)-'@')  
7188 
7189 void
7190 consoleintr(int (*getc)(void))
7191 {
7192   int c, doprocdump = 0;
7193 
7194   acquire(&cons.lock);
7195   while((c = getc()) >= 0){
7196     switch(c){
7197     case C('P'):  
7198       doprocdump = 1;   
7199       break;
7200     case C('U'):  
7201       while(input.e != input.w &&
7202             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
7203         input.e--;
7204         consputc(BACKSPACE);
7205       }
7206       break;
7207     case C('H'): case '\x7f':  
7208       if(input.e != input.w){
7209         input.e--;
7210         consputc(BACKSPACE);
7211       }
7212       break;
7213     default:
7214       if(c != 0 && input.e-input.r < INPUT_BUF){
7215         c = (c == '\r') ? '\n' : c;
7216         input.buf[input.e++ % INPUT_BUF] = c;
7217         consputc(c);
7218         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
7219           input.w = input.e;
7220           wakeup(&input.r);
7221         }
7222       }
7223       break;
7224     }
7225   }
7226   release(&cons.lock);
7227   if(doprocdump) {
7228     procdump();  
7229   }
7230 }
7231 
7232 int
7233 consoleread(struct inode *ip, char *dst, int n)
7234 {
7235   uint target;
7236   int c;
7237 
7238   iunlock(ip);
7239   target = n;
7240   acquire(&cons.lock);
7241   while(n > 0){
7242     while(input.r == input.w){
7243       if(proc->killed){
7244         release(&cons.lock);
7245         ilock(ip);
7246         return -1;
7247       }
7248       sleep(&input.r, &cons.lock);
7249     }
7250     c = input.buf[input.r++ % INPUT_BUF];
7251     if(c == C('D')){  
7252       if(n < target){
7253         
7254         
7255         input.r--;
7256       }
7257       break;
7258     }
7259     *dst++ = c;
7260     --n;
7261     if(c == '\n')
7262       break;
7263   }
7264   release(&cons.lock);
7265   ilock(ip);
7266 
7267   return target - n;
7268 }
7269 
7270 int
7271 consolewrite(struct inode *ip, char *buf, int n)
7272 {
7273   int i;
7274 
7275   iunlock(ip);
7276   acquire(&cons.lock);
7277   for(i = 0; i < n; i++)
7278     consputc(buf[i] & 0xff);
7279   release(&cons.lock);
7280   ilock(ip);
7281 
7282   return n;
7283 }
7284 
7285 void
7286 consoleinit(void)
7287 {
7288   initlock(&cons.lock, "console");
7289 
7290   devsw[CONSOLE].write = consolewrite;
7291   devsw[CONSOLE].read = consoleread;
7292   cons.locking = 1;
7293 
7294   picenable(IRQ_KBD);
7295   ioapicenable(IRQ_KBD, 0);
7296 }
7297 
7298 
7299 
7300 
7301 
7302 
7303 
7304 #include "types.h"
7305 #include "defs.h"
7306 #include "traps.h"
7307 #include "x86.h"
7308 
7309 #define IO_TIMER1       0x040           
7310 
7311 
7312 
7313 
7314 
7315 #define TIMER_FREQ      1193182
7316 #define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
7317 
7318 #define TIMER_MODE      (IO_TIMER1 + 3) 
7319 #define TIMER_SEL0      0x00    
7320 #define TIMER_RATEGEN   0x04    
7321 #define TIMER_16BIT     0x30    
7322 
7323 void
7324 timerinit(void)
7325 {
7326   
7327   outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
7328   outb(IO_TIMER1, TIMER_DIV(100) % 256);
7329   outb(IO_TIMER1, TIMER_DIV(100) / 256);
7330   picenable(IRQ_TIMER);
7331 }
7332 
7333 
7334 
7335 
7336 
7337 
7338 
7339 
7340 
7341 
7342 
7343 
7344 
7345 
7346 
7347 
7348 
7349 
7350 
7351 
7352 #include "types.h"
7353 #include "defs.h"
7354 #include "param.h"
7355 #include "traps.h"
7356 #include "spinlock.h"
7357 #include "fs.h"
7358 #include "file.h"
7359 #include "mmu.h"
7360 #include "proc.h"
7361 #include "x86.h"
7362 
7363 #define COM1    0x3f8
7364 
7365 static int uart;    
7366 
7367 void
7368 uartinit(void)
7369 {
7370   char *p;
7371 
7372   
7373   outb(COM1+2, 0);
7374 
7375   
7376   outb(COM1+3, 0x80);    
7377   outb(COM1+0, 115200/9600);
7378   outb(COM1+1, 0);
7379   outb(COM1+3, 0x03);    
7380   outb(COM1+4, 0);
7381   outb(COM1+1, 0x01);    
7382 
7383   
7384   if(inb(COM1+5) == 0xFF)
7385     return;
7386   uart = 1;
7387 
7388   
7389   
7390   inb(COM1+2);
7391   inb(COM1+0);
7392   picenable(IRQ_COM1);
7393   ioapicenable(IRQ_COM1, 0);
7394 
7395   
7396   for(p="xv6...\n"; *p; p++)
7397     uartputc(*p);
7398 }
7399 
7400 void
7401 uartputc(int c)
7402 {
7403   int i;
7404 
7405   if(!uart)
7406     return;
7407   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
7408     microdelay(10);
7409   outb(COM1+0, c);
7410 }
7411 
7412 static int
7413 uartgetc(void)
7414 {
7415   if(!uart)
7416     return -1;
7417   if(!(inb(COM1+5) & 0x01))
7418     return -1;
7419   return inb(COM1+0);
7420 }
7421 
7422 void
7423 uartintr(void)
7424 {
7425   consoleintr(uartgetc);
7426 }
7427 
7428 
7429 
7430 
7431 
7432 
7433 
7434 
7435 
7436 
7437 
7438 
7439 
7440 
7441 
7442 
7443 
7444 
7445 
7446 
7447 
7448 
7449 
7450 
7451 
7452 
7453 
7454 
7455 
7456 
7457 .globl start
7458 start:
7459   pushl $argv
7460   pushl $init
7461   pushl $0  
7462   movl $SYS_exec, %eax
7463   int $T_SYSCALL
7464 
7465 
7466 exit:
7467   movl $SYS_exit, %eax
7468   int $T_SYSCALL
7469   jmp exit
7470 
7471 
7472 init:
7473   .string "/init\0"
7474 
7475 
7476 .p2align 2
7477 argv:
7478   .long init
7479   .long 0
7480 
7481 
7482 
7483 
7484 
7485 
7486 
7487 
7488 
7489 
7490 
7491 
7492 
7493 
7494 
7495 
7496 
7497 
7498 
7499 
7500 
7501 
7502 
7503 
7504   .globl name; \
7505   name: \
7506     movl $SYS_ 
7507     int $T_SYSCALL; \
7508     ret
7509 
7510 SYSCALL(fork)
7511 SYSCALL(exit)
7512 SYSCALL(wait)
7513 SYSCALL(pipe)
7514 SYSCALL(read)
7515 SYSCALL(write)
7516 SYSCALL(close)
7517 SYSCALL(kill)
7518 SYSCALL(exec)
7519 SYSCALL(open)
7520 SYSCALL(mknod)
7521 SYSCALL(unlink)
7522 SYSCALL(fstat)
7523 SYSCALL(link)
7524 SYSCALL(mkdir)
7525 SYSCALL(chdir)
7526 SYSCALL(dup)
7527 SYSCALL(getpid)
7528 SYSCALL(sbrk)
7529 SYSCALL(sleep)
7530 SYSCALL(uptime)
7531 
7532 
7533 
7534 
7535 
7536 
7537 
7538 
7539 
7540 
7541 
7542 
7543 
7544 
7545 
7546 
7547 
7548 
7549 
7550 
7551 
7552 #include "types.h"
7553 #include "stat.h"
7554 #include "user.h"
7555 #include "fcntl.h"
7556 
7557 char *argv[] = { "sh", 0 };
7558 
7559 int
7560 main(void)
7561 {
7562   int pid, wpid;
7563 
7564   if(open("console", O_RDWR) < 0){
7565     mknod("console", 1, 1);
7566     open("console", O_RDWR);
7567   }
7568   dup(0);  
7569   dup(0);  
7570 
7571   for(;;){
7572     printf(1, "init: starting sh\n");
7573     pid = fork();
7574     if(pid < 0){
7575       printf(1, "init: fork failed\n");
7576       exit();
7577     }
7578     if(pid == 0){
7579       exec("sh", argv);
7580       printf(1, "init: exec sh failed\n");
7581       exit();
7582     }
7583     while((wpid=wait()) >= 0 && wpid != pid)
7584       printf(1, "zombie!\n");
7585   }
7586 }
7587 
7588 
7589 
7590 
7591 
7592 
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 
7601 
7602 #include "types.h"
7603 #include "user.h"
7604 #include "fcntl.h"
7605 
7606 
7607 #define EXEC  1
7608 #define REDIR 2
7609 #define PIPE  3
7610 #define LIST  4
7611 #define BACK  5
7612 
7613 #define MAXARGS 10
7614 
7615 struct cmd {
7616   int type;
7617 };
7618 
7619 struct execcmd {
7620   int type;
7621   char *argv[MAXARGS];
7622   char *eargv[MAXARGS];
7623 };
7624 
7625 struct redircmd {
7626   int type;
7627   struct cmd *cmd;
7628   char *file;
7629   char *efile;
7630   int mode;
7631   int fd;
7632 };
7633 
7634 struct pipecmd {
7635   int type;
7636   struct cmd *left;
7637   struct cmd *right;
7638 };
7639 
7640 struct listcmd {
7641   int type;
7642   struct cmd *left;
7643   struct cmd *right;
7644 };
7645 
7646 struct backcmd {
7647   int type;
7648   struct cmd *cmd;
7649 };
7650 int fork1(void);  
7651 void panic(char*);
7652 struct cmd *parsecmd(char*);
7653 
7654 
7655 void
7656 runcmd(struct cmd *cmd)
7657 {
7658   int p[2];
7659   struct backcmd *bcmd;
7660   struct execcmd *ecmd;
7661   struct listcmd *lcmd;
7662   struct pipecmd *pcmd;
7663   struct redircmd *rcmd;
7664 
7665   if(cmd == 0)
7666     exit();
7667 
7668   switch(cmd->type){
7669   default:
7670     panic("runcmd");
7671 
7672   case EXEC:
7673     ecmd = (struct execcmd*)cmd;
7674     if(ecmd->argv[0] == 0)
7675       exit();
7676     exec(ecmd->argv[0], ecmd->argv);
7677     printf(2, "exec %s failed\n", ecmd->argv[0]);
7678     break;
7679 
7680   case REDIR:
7681     rcmd = (struct redircmd*)cmd;
7682     close(rcmd->fd);
7683     if(open(rcmd->file, rcmd->mode) < 0){
7684       printf(2, "open %s failed\n", rcmd->file);
7685       exit();
7686     }
7687     runcmd(rcmd->cmd);
7688     break;
7689 
7690   case LIST:
7691     lcmd = (struct listcmd*)cmd;
7692     if(fork1() == 0)
7693       runcmd(lcmd->left);
7694     wait();
7695     runcmd(lcmd->right);
7696     break;
7697 
7698 
7699 
7700   case PIPE:
7701     pcmd = (struct pipecmd*)cmd;
7702     if(pipe(p) < 0)
7703       panic("pipe");
7704     if(fork1() == 0){
7705       close(1);
7706       dup(p[1]);
7707       close(p[0]);
7708       close(p[1]);
7709       runcmd(pcmd->left);
7710     }
7711     if(fork1() == 0){
7712       close(0);
7713       dup(p[0]);
7714       close(p[0]);
7715       close(p[1]);
7716       runcmd(pcmd->right);
7717     }
7718     close(p[0]);
7719     close(p[1]);
7720     wait();
7721     wait();
7722     break;
7723 
7724   case BACK:
7725     bcmd = (struct backcmd*)cmd;
7726     if(fork1() == 0)
7727       runcmd(bcmd->cmd);
7728     break;
7729   }
7730   exit();
7731 }
7732 
7733 int
7734 getcmd(char *buf, int nbuf)
7735 {
7736   printf(2, "$ ");
7737   memset(buf, 0, nbuf);
7738   gets(buf, nbuf);
7739   if(buf[0] == 0) 
7740     return -1;
7741   return 0;
7742 }
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 int
7751 main(void)
7752 {
7753   static char buf[100];
7754   int fd;
7755 
7756   
7757   while((fd = open("console", O_RDWR)) >= 0){
7758     if(fd >= 3){
7759       close(fd);
7760       break;
7761     }
7762   }
7763 
7764   
7765   while(getcmd(buf, sizeof(buf)) >= 0){
7766     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
7767       
7768       
7769       buf[strlen(buf)-1] = 0;  
7770       if(chdir(buf+3) < 0)
7771         printf(2, "cannot cd %s\n", buf+3);
7772       continue;
7773     }
7774     if(fork1() == 0)
7775       runcmd(parsecmd(buf));
7776     wait();
7777   }
7778   exit();
7779 }
7780 
7781 void
7782 panic(char *s)
7783 {
7784   printf(2, "%s\n", s);
7785   exit();
7786 }
7787 
7788 int
7789 fork1(void)
7790 {
7791   int pid;
7792 
7793   pid = fork();
7794   if(pid == -1)
7795     panic("fork");
7796   return pid;
7797 }
7798 
7799 
7800 
7801 
7802 struct cmd*
7803 execcmd(void)
7804 {
7805   struct execcmd *cmd;
7806 
7807   cmd = malloc(sizeof(*cmd));
7808   memset(cmd, 0, sizeof(*cmd));
7809   cmd->type = EXEC;
7810   return (struct cmd*)cmd;
7811 }
7812 
7813 struct cmd*
7814 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
7815 {
7816   struct redircmd *cmd;
7817 
7818   cmd = malloc(sizeof(*cmd));
7819   memset(cmd, 0, sizeof(*cmd));
7820   cmd->type = REDIR;
7821   cmd->cmd = subcmd;
7822   cmd->file = file;
7823   cmd->efile = efile;
7824   cmd->mode = mode;
7825   cmd->fd = fd;
7826   return (struct cmd*)cmd;
7827 }
7828 
7829 struct cmd*
7830 pipecmd(struct cmd *left, struct cmd *right)
7831 {
7832   struct pipecmd *cmd;
7833 
7834   cmd = malloc(sizeof(*cmd));
7835   memset(cmd, 0, sizeof(*cmd));
7836   cmd->type = PIPE;
7837   cmd->left = left;
7838   cmd->right = right;
7839   return (struct cmd*)cmd;
7840 }
7841 
7842 
7843 
7844 
7845 
7846 
7847 
7848 
7849 
7850 struct cmd*
7851 listcmd(struct cmd *left, struct cmd *right)
7852 {
7853   struct listcmd *cmd;
7854 
7855   cmd = malloc(sizeof(*cmd));
7856   memset(cmd, 0, sizeof(*cmd));
7857   cmd->type = LIST;
7858   cmd->left = left;
7859   cmd->right = right;
7860   return (struct cmd*)cmd;
7861 }
7862 
7863 struct cmd*
7864 backcmd(struct cmd *subcmd)
7865 {
7866   struct backcmd *cmd;
7867 
7868   cmd = malloc(sizeof(*cmd));
7869   memset(cmd, 0, sizeof(*cmd));
7870   cmd->type = BACK;
7871   cmd->cmd = subcmd;
7872   return (struct cmd*)cmd;
7873 }
7874 
7875 
7876 char whitespace[] = " \t\r\n\v";
7877 char symbols[] = "<|>&;()";
7878 
7879 int
7880 gettoken(char **ps, char *es, char **q, char **eq)
7881 {
7882   char *s;
7883   int ret;
7884 
7885   s = *ps;
7886   while(s < es && strchr(whitespace, *s))
7887     s++;
7888   if(q)
7889     *q = s;
7890   ret = *s;
7891   switch(*s){
7892   case 0:
7893     break;
7894   case '|':
7895   case '(':
7896   case ')':
7897   case ';':
7898   case '&':
7899   case '<':
7900     s++;
7901     break;
7902   case '>':
7903     s++;
7904     if(*s == '>'){
7905       ret = '+';
7906       s++;
7907     }
7908     break;
7909   default:
7910     ret = 'a';
7911     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
7912       s++;
7913     break;
7914   }
7915   if(eq)
7916     *eq = s;
7917 
7918   while(s < es && strchr(whitespace, *s))
7919     s++;
7920   *ps = s;
7921   return ret;
7922 }
7923 
7924 int
7925 peek(char **ps, char *es, char *toks)
7926 {
7927   char *s;
7928 
7929   s = *ps;
7930   while(s < es && strchr(whitespace, *s))
7931     s++;
7932   *ps = s;
7933   return *s && strchr(toks, *s);
7934 }
7935 
7936 
7937 
7938 
7939 
7940 
7941 
7942 
7943 
7944 
7945 
7946 
7947 
7948 
7949 
7950 struct cmd *parseline(char**, char*);
7951 struct cmd *parsepipe(char**, char*);
7952 struct cmd *parseexec(char**, char*);
7953 struct cmd *nulterminate(struct cmd*);
7954 
7955 struct cmd*
7956 parsecmd(char *s)
7957 {
7958   char *es;
7959   struct cmd *cmd;
7960 
7961   es = s + strlen(s);
7962   cmd = parseline(&s, es);
7963   peek(&s, es, "");
7964   if(s != es){
7965     printf(2, "leftovers: %s\n", s);
7966     panic("syntax");
7967   }
7968   nulterminate(cmd);
7969   return cmd;
7970 }
7971 
7972 struct cmd*
7973 parseline(char **ps, char *es)
7974 {
7975   struct cmd *cmd;
7976 
7977   cmd = parsepipe(ps, es);
7978   while(peek(ps, es, "&")){
7979     gettoken(ps, es, 0, 0);
7980     cmd = backcmd(cmd);
7981   }
7982   if(peek(ps, es, ";")){
7983     gettoken(ps, es, 0, 0);
7984     cmd = listcmd(cmd, parseline(ps, es));
7985   }
7986   return cmd;
7987 }
7988 
7989 
7990 
7991 
7992 
7993 
7994 
7995 
7996 
7997 
7998 
7999 
8000 struct cmd*
8001 parsepipe(char **ps, char *es)
8002 {
8003   struct cmd *cmd;
8004 
8005   cmd = parseexec(ps, es);
8006   if(peek(ps, es, "|")){
8007     gettoken(ps, es, 0, 0);
8008     cmd = pipecmd(cmd, parsepipe(ps, es));
8009   }
8010   return cmd;
8011 }
8012 
8013 struct cmd*
8014 parseredirs(struct cmd *cmd, char **ps, char *es)
8015 {
8016   int tok;
8017   char *q, *eq;
8018 
8019   while(peek(ps, es, "<>")){
8020     tok = gettoken(ps, es, 0, 0);
8021     if(gettoken(ps, es, &q, &eq) != 'a')
8022       panic("missing file for redirection");
8023     switch(tok){
8024     case '<':
8025       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
8026       break;
8027     case '>':
8028       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8029       break;
8030     case '+':  
8031       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8032       break;
8033     }
8034   }
8035   return cmd;
8036 }
8037 
8038 
8039 
8040 
8041 
8042 
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 struct cmd*
8051 parseblock(char **ps, char *es)
8052 {
8053   struct cmd *cmd;
8054 
8055   if(!peek(ps, es, "("))
8056     panic("parseblock");
8057   gettoken(ps, es, 0, 0);
8058   cmd = parseline(ps, es);
8059   if(!peek(ps, es, ")"))
8060     panic("syntax - missing )");
8061   gettoken(ps, es, 0, 0);
8062   cmd = parseredirs(cmd, ps, es);
8063   return cmd;
8064 }
8065 
8066 struct cmd*
8067 parseexec(char **ps, char *es)
8068 {
8069   char *q, *eq;
8070   int tok, argc;
8071   struct execcmd *cmd;
8072   struct cmd *ret;
8073 
8074   if(peek(ps, es, "("))
8075     return parseblock(ps, es);
8076 
8077   ret = execcmd();
8078   cmd = (struct execcmd*)ret;
8079 
8080   argc = 0;
8081   ret = parseredirs(ret, ps, es);
8082   while(!peek(ps, es, "|)&;")){
8083     if((tok=gettoken(ps, es, &q, &eq)) == 0)
8084       break;
8085     if(tok != 'a')
8086       panic("syntax");
8087     cmd->argv[argc] = q;
8088     cmd->eargv[argc] = eq;
8089     argc++;
8090     if(argc >= MAXARGS)
8091       panic("too many args");
8092     ret = parseredirs(ret, ps, es);
8093   }
8094   cmd->argv[argc] = 0;
8095   cmd->eargv[argc] = 0;
8096   return ret;
8097 }
8098 
8099 
8100 
8101 struct cmd*
8102 nulterminate(struct cmd *cmd)
8103 {
8104   int i;
8105   struct backcmd *bcmd;
8106   struct execcmd *ecmd;
8107   struct listcmd *lcmd;
8108   struct pipecmd *pcmd;
8109   struct redircmd *rcmd;
8110 
8111   if(cmd == 0)
8112     return 0;
8113 
8114   switch(cmd->type){
8115   case EXEC:
8116     ecmd = (struct execcmd*)cmd;
8117     for(i=0; ecmd->argv[i]; i++)
8118       *ecmd->eargv[i] = 0;
8119     break;
8120 
8121   case REDIR:
8122     rcmd = (struct redircmd*)cmd;
8123     nulterminate(rcmd->cmd);
8124     *rcmd->efile = 0;
8125     break;
8126 
8127   case PIPE:
8128     pcmd = (struct pipecmd*)cmd;
8129     nulterminate(pcmd->left);
8130     nulterminate(pcmd->right);
8131     break;
8132 
8133   case LIST:
8134     lcmd = (struct listcmd*)cmd;
8135     nulterminate(lcmd->left);
8136     nulterminate(lcmd->right);
8137     break;
8138 
8139   case BACK:
8140     bcmd = (struct backcmd*)cmd;
8141     nulterminate(bcmd->cmd);
8142     break;
8143   }
8144   return cmd;
8145 }
8146 
8147 
8148 
8149 
8150 
8151 
8152 
8153 
8154 
8155 
8156 
8157 
8158 
8159 .code16                       
8160 .globl start
8161 start:
8162   cli                         
8163 
8164   
8165   xorw    %ax,%ax             
8166   movw    %ax,%ds             
8167   movw    %ax,%es             
8168   movw    %ax,%ss             
8169 
8170   
8171   
8172 seta20.1:
8173   inb     $0x64,%al               
8174   testb   $0x2,%al
8175   jnz     seta20.1
8176 
8177   movb    $0xd1,%al               
8178   outb    %al,$0x64
8179 
8180 seta20.2:
8181   inb     $0x64,%al               
8182   testb   $0x2,%al
8183   jnz     seta20.2
8184 
8185   movb    $0xdf,%al               
8186   outb    %al,$0x60
8187 
8188   
8189   
8190   
8191   lgdt    gdtdesc
8192   movl    %cr0, %eax
8193   orl     $CR0_PE, %eax
8194   movl    %eax, %cr0
8195 
8196   
8197   
8198   
8199   ljmp    $(SEG_KCODE<<3), $start32
8200 .code32  
8201 start32:
8202   
8203   movw    $(SEG_KDATA<<3), %ax    
8204   movw    %ax, %ds                
8205   movw    %ax, %es                
8206   movw    %ax, %ss                
8207   movw    $0, %ax                 
8208   movw    %ax, %fs                
8209   movw    %ax, %gs                
8210 
8211   
8212   movl    $start, %esp
8213   call    bootmain
8214 
8215   
8216   
8217   movw    $0x8a00, %ax            
8218   movw    %ax, %dx
8219   outw    %ax, %dx
8220   movw    $0x8ae0, %ax            
8221   outw    %ax, %dx
8222 spin:
8223   jmp     spin
8224 
8225 
8226 .p2align 2                                
8227 gdt:
8228   SEG_NULLASM                             
8229   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
8230   SEG_ASM(STA_W, 0x0, 0xffffffff)         
8231 
8232 gdtdesc:
8233   .word   (gdtdesc - gdt - 1)             
8234   .long   gdt                             
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 
8252 
8253 
8254 
8255 
8256 
8257 #include "types.h"
8258 #include "elf.h"
8259 #include "x86.h"
8260 #include "memlayout.h"
8261 
8262 #define SECTSIZE  512
8263 
8264 void readseg(uchar*, uint, uint);
8265 
8266 void
8267 bootmain(void)
8268 {
8269   struct elfhdr *elf;
8270   struct proghdr *ph, *eph;
8271   void (*entry)(void);
8272   uchar* pa;
8273 
8274   elf = (struct elfhdr*)0x10000;  
8275 
8276   
8277   readseg((uchar*)elf, 4096, 0);
8278 
8279   
8280   if(elf->magic != ELF_MAGIC)
8281     return;  
8282 
8283   
8284   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
8285   eph = ph + elf->phnum;
8286   for(; ph < eph; ph++){
8287     pa = (uchar*)ph->paddr;
8288     readseg(pa, ph->filesz, ph->off);
8289     if(ph->memsz > ph->filesz)
8290       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
8291   }
8292 
8293   
8294   
8295   entry = (void(*)(void))(elf->entry);
8296   entry();
8297 }
8298 
8299 
8300 void
8301 waitdisk(void)
8302 {
8303   
8304   while((inb(0x1F7) & 0xC0) != 0x40)
8305     ;
8306 }
8307 
8308 
8309 void
8310 readsect(void *dst, uint offset)
8311 {
8312   
8313   waitdisk();
8314   outb(0x1F2, 1);   
8315   outb(0x1F3, offset);
8316   outb(0x1F4, offset >> 8);
8317   outb(0x1F5, offset >> 16);
8318   outb(0x1F6, (offset >> 24) | 0xE0);
8319   outb(0x1F7, 0x20);  
8320 
8321   
8322   waitdisk();
8323   insl(0x1F0, dst, SECTSIZE/4);
8324 }
8325 
8326 
8327 
8328 void
8329 readseg(uchar* pa, uint count, uint offset)
8330 {
8331   uchar* epa;
8332 
8333   epa = pa + count;
8334 
8335   
8336   pa -= offset % SECTSIZE;
8337 
8338   
8339   offset = (offset / SECTSIZE) + 1;
8340 
8341   
8342   
8343   
8344   for(; pa < epa; pa += SECTSIZE, offset++)
8345     readsect(pa, offset);
8346 }
8347 
8348 
8349 
